# librime 派生规则（derive）代码流程分析

## 问题场景

在双拼方案中配置了派生规则：
```yaml
speller:
  algebra:
    - derive/e/w/
    - derive/t/r/
    # ... 更多派生规则
```

**问题**：当用户输入 `w` 时，如何同时匹配到 `e` 和 `w` 对应的音节？

---

## 核心概念

### 1. 关键数据结构

- **Syllabary（音节表）**：原始音节集合，来自词典文件（如 `['e', 'w', 'bu', 'pu', ...]`）
- **Script（脚本）**：经过代数运算后的音节映射表，结构为 `map<string, vector<Spelling>>`
  - 键：用户输入的拼写（如 `'w'`）
  - 值：该拼写对应的所有音节及其属性（如 `[{str:'w', type:normal}, {str:'e', type:normal}]`）
- **Prism（音节图）**：基于 Script 构建的双数组 Trie 树，用于快速查询

### 2. Spelling 结构

```cpp
struct Spelling {
  string str;                    // 实际音节（如 'e'）
  SpellingProperties properties; // 属性（类型、可信度等）
};
```

---

## 完整流程分析

### 阶段一：编译期 - 构建音节图

#### 1. 加载原始音节表（DictCompiler::BuildPrism）

**文件**：`src/rime/dict/dict_compiler.cc:304-310`

```cpp
Syllabary syllabary;
primary_table->GetSyllabary(&syllabary);
// syllabary = ['e', 'w', 'bu', 'pu', ...]
```

#### 2. 初始化 Script（DictCompiler::BuildPrism）

**文件**：`src/rime/dict/dict_compiler.cc:311-327`

```cpp
Script script;
for (const auto& x : syllabary) {
  script.AddSyllable(x);  // 为每个音节创建初始映射
}
// 此时 script = {
//   'e': [{str:'e', type:normal}],
//   'w': [{str:'w', type:normal}],
//   ...
// }
```

**实现**：`src/rime/algo/algebra.cc:14-20`

```cpp
bool Script::AddSyllable(const string& syllable) {
  Spelling spelling(syllable);
  (*this)[syllable].push_back(spelling);
  return true;
}
```

#### 3. 加载并解析代数规则（Projection::Load）

**文件**：`src/rime/algo/algebra.cc:64-96`

```cpp
Projection p;
auto algebra = config.GetList("speller/algebra");
p.Load(algebra);  // 解析所有 derive/xform/erase 等规则
```

**解析过程**（Calculus::Parse）：

**文件**：`src/rime/algo/calculus.cc:30-42`

```cpp
Calculation* Calculus::Parse(const string& definition) {
  // 输入: "derive/e/w/"
  // 1. 找到分隔符 '/'
  size_t sep = definition.find_first_not_of("abcd...xyz");
  
  // 2. 按分隔符切分
  vector<string> args;
  boost::split(args, definition, boost::is_from_range('/', '/'));
  // args = ["derive", "e", "w"]
  
  // 3. 查找对应的工厂函数
  auto it = factories_.find(args[0]);  // 找到 "derive" -> Derivation::Parse
  return it->second(args);
}
```

**Derivation 创建**：

**文件**：`src/rime/algo/calculus.cc:145-156`

```cpp
Calculation* Derivation::Parse(const vector<string>& args) {
  const string& left(args[1]);   // "e"
  const string& right(args[2]);  // "w"
  
  the<Derivation> x(new Derivation);
  x->pattern_.assign(left);       // 正则表达式: "e"
  x->replacement_.assign(right);  // 替换为: "w"
  return x.release();
}
```

#### 4. 应用代数规则到 Script（Projection::Apply）

**文件**：`src/rime/algo/algebra.cc:117-150`

这是**最核心**的逻辑！

```cpp
bool Projection::Apply(Script* value) {
  for (an<Calculation>& x : calculation_) {  // 遍历每条规则
    Script temp;
    
    for (const Script::value_type& v : *value) {  // 遍历当前所有映射
      Spelling s(v.first);  // 取出键（如 'e'）
      bool applied = x->Apply(&s);  // 尝试应用规则
      
      if (applied) {
        // 规则匹配成功
        if (!x->deletion()) {
          // derive 不删除原项，保留原映射
          temp.Merge(v.first, SpellingProperties(), v.second);
          // temp['e'] = [{str:'e', type:normal}]
        }
        
        if (x->addition() && !s.str.empty()) {
          // derive 是 addition 类型，添加新映射
          temp.Merge(s.str, s.properties, v.second);
          // temp['w'] = [{str:'e', type:normal}]  ← 关键！
        }
      } else {
        // 规则不匹配，保留原项
        temp.Merge(v.first, SpellingProperties(), v.second);
      }
    }
    
    value->swap(temp);  // 替换为新的 Script
  }
}
```

**Transformation::Apply（Derivation 继承）**：

**文件**：`src/rime/algo/calculus.cc:111-119`

```cpp
bool Transformation::Apply(Spelling* spelling) {
  // 输入: spelling->str = "e"
  // pattern_ = "e", replacement_ = "w"
  
  string result = boost::regex_replace(spelling->str, pattern_, replacement_);
  // result = "w"
  
  if (result == spelling->str)
    return false;  // 未修改
  
  spelling->str.swap(result);  // spelling->str = "w"
  return true;
}
```

**Script::Merge（合并映射）**：

**文件**：`src/rime/algo/algebra.cc:22-48`

```cpp
void Script::Merge(const string& s,           // 键: "w"
                   const SpellingProperties& sp,
                   const vector<Spelling>& v) {  // 值: [{str:'e'}]
  vector<Spelling>& m((*this)[s]);  // 获取 script["w"]
  
  for (const Spelling& x : v) {
    Spelling y(x);  // 复制 {str:'e'}
    // 合并属性...
    
    auto e = std::find(m.begin(), m.end(), x);
    if (e == m.end()) {
      m.push_back(y);  // 添加到 script["w"]
    }
  }
  // 结果: script["w"] = [{str:'w', type:normal}, {str:'e', type:normal}]
}
```

**应用 `derive/e/w/` 后的 Script 状态**：

```cpp
script = {
  'e': [{str:'e', type:normal}],           // 原项保留
  'w': [{str:'w', type:normal},            // 原项保留
        {str:'e', type:normal}],           // 新增！从 'e' 派生而来
  ...
}
```

#### 5. 构建 Prism 双数组 Trie（Prism::Build）

**文件**：`src/rime/dict/prism.cc:124-223`

```cpp
bool Prism::Build(const Syllabary& syllabary, const Script* script, ...) {
  // 1. 构建 Trie 树
  vector<const char*> keys;
  for (auto it = script->begin(); it != script->end(); ++it) {
    keys.push_back(it->first.c_str());  // ['e', 'w', ...]
  }
  trie_->build(num_spellings, &keys[0]);
  
  // 2. 构建 spelling_map（拼写映射表）
  map<string, SyllableId> syllable_to_id;
  SyllableId syll_id = 0;
  for (auto it = syllabary.begin(); it != syllabary.end(); ++it) {
    syllable_to_id[*it] = syll_id++;
    // syllable_to_id = {'e':0, 'w':1, 'bu':2, ...}
  }
  
  auto spelling_map = CreateArray<SpellingMapItem>(num_spellings);
  auto i = script->begin();
  auto item = spelling_map->begin();
  
  for (; i != script->end(); ++i, ++item) {
    // 遍历 script 的每个键值对
    // 例如: i->first = "w", i->second = [{str:'w'}, {str:'e'}]
    
    size_t list_size = i->second.size();  // 2
    item->size = list_size;
    item->at = Allocate<SpellingDescriptor>(list_size);
    
    auto j = i->second.begin();
    auto desc = item->begin();
    for (; j != i->second.end(); ++j, ++desc) {
      // j->str = "w" 或 "e"
      desc->syllable_id = syllable_to_id[j->str];  // 0 或 1
      desc->type = j->properties.type;
      desc->credibility = j->properties.credibility;
    }
  }
  
  // 结果: spelling_map["w"] = [
  //   {syllable_id:1, type:normal},  // 'w'
  //   {syllable_id:0, type:normal}   // 'e'
  // ]
}
```

---

### 阶段二：运行期 - 查询音节

#### 1. 用户输入 'w'（Prism::CommonPrefixSearch）

**文件**：`src/rime/dict/prism.cc:252-260`

```cpp
void Prism::CommonPrefixSearch(const string& key, vector<Match>* result) {
  // key = "w"
  size_t num_results = trie_->commonPrefixSearch(key.c_str(), ...);
  // 返回所有以 'w' 为前缀的匹配
  // result = [{value:spelling_id_of_w, length:1}]
}
```

#### 2. 查询拼写对应的音节（Prism::QuerySpelling）

**文件**：`src/rime/dict/prism.cc:306-308`

```cpp
SpellingAccessor Prism::QuerySpelling(SyllableId spelling_id) {
  return SpellingAccessor(spelling_map_, spelling_id);
  // 返回 spelling_map[spelling_id] 的迭代器
}
```

#### 3. 遍历所有音节（SpellingAccessor）

**文件**：`src/rime/dict/prism.cc:310-323`

```cpp
SpellingAccessor accessor = prism->QuerySpelling(spelling_id);
while (!accessor.exhausted()) {
  SyllableId syll_id = accessor.syllable_id();
  // 第一次: syll_id = 1 (对应 'w')
  // 第二次: syll_id = 0 (对应 'e')
  
  SpellingProperties props = accessor.properties();
  // 获取类型、可信度等属性
  
  accessor.Next();
}
```

---

## 关键点总结

### 1. derive 规则的本质

`derive/e/w/` 的作用是：
- **保留原映射**：`'e' -> [{str:'e'}]`
- **创建新映射**：`'w' -> [{str:'w'}, {str:'e'}]`

这样用户输入 `w` 时，既能匹配到音节 `w`，也能匹配到音节 `e`。

### 2. 为什么不是反向派生？

注意：`derive/e/w/` **不会**创建 `'e' -> [{str:'e'}, {str:'w'}]`。

规则的方向是：
- **左侧（pattern）**：匹配 Script 的**键**（用户输入）
- **右侧（replacement）**：生成新的**键**，并将原**值**复制过去

所以 `derive/e/w/` 的含义是：
> "当 Script 中存在键 'e' 时，创建新键 'w'，并让 'w' 也能匹配到 'e' 对应的音节"

### 3. 双向派生的实现

如果需要双向派生（输入 `e` 或 `w` 都能匹配两个音节），需要两条规则：
```yaml
speller:
  algebra:
    - derive/e/w/  # 输入 w 可以匹配 e
    - derive/w/e/  # 输入 e 可以匹配 w
```

### 4. 性能优化

- **编译期计算**：所有代数运算在部署时完成，生成 `.prism.bin` 文件
- **运行期查询**：使用双数组 Trie 树（Darts），查询复杂度 O(|key|)
- **内存映射**：Prism 使用 mmap，无需加载整个文件到内存

---

## 调试技巧

### 1. 查看 Script 内容

在编译词典时添加 `--dump` 选项：
```bash
rime_deployer --build /path/to/user_data --dump
```

会生成 `*.prism.txt` 文件，内容示例：
```
e	e	-	0	
w	w	-	0	
w	e	-	0	← 派生项
```

格式：`用户输入 \t 实际音节 \t 类型 \t 可信度 \t 提示`

### 2. 添加日志

在 `src/rime/algo/algebra.cc:124` 添加：
```cpp
DLOG(INFO) << "Applying rule to: " << v.first 
           << " -> " << s.str 
           << " (applied: " << applied << ")";
```

### 3. 单元测试

参考 `test/algebra_test.cc` 编写测试用例：
```cpp
TEST(AlgebraTest, Derivation) {
  Script script;
  script.AddSyllable("e");
  script.AddSyllable("w");
  
  Projection p;
  p.Load({"derive/e/w/"});
  p.Apply(&script);
  
  EXPECT_EQ(script["w"].size(), 2);  // 'w' 和 'e'
  EXPECT_EQ(script["w"][1].str, "e");
}
```

---

## 相关文件索引

| 功能 | 文件 | 关键函数 |
|------|------|----------|
| 代数规则解析 | `src/rime/algo/calculus.{h,cc}` | `Calculus::Parse`, `Derivation::Parse` |
| 规则应用 | `src/rime/algo/algebra.{h,cc}` | `Projection::Apply`, `Script::Merge` |
| Trie 构建 | `src/rime/dict/prism.{h,cc}` | `Prism::Build` |
| 音节查询 | `src/rime/dict/prism.{h,cc}` | `Prism::QuerySpelling` |
| 词典编译 | `src/rime/dict/dict_compiler.cc` | `DictCompiler::BuildPrism` |

---

## 扩展阅读

- **Darts 双数组 Trie**：https://github.com/s-yata/darts-clone
- **Boost.Regex**：https://www.boost.org/doc/libs/release/libs/regex/
- **RIME 拼写运算文档**：https://github.com/rime/home/wiki/SpellingAlgebra
