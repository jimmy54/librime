# 双拼方案音节映射构建分析

## 规则概览

这是一个典型的**双拼方案**（如自然码、小鹤双拼等）的实现，通过两步转换：

1. **xform（变换）**：将全拼音节转换为临时符号（使用特殊字符 Ⓤ Ⓘ Ⓥ 等）
2. **xlit（音译）**：将临时符号批量替换为最终的双拼按键

---

## 完整示例：音节 "zhang1" 的转换过程

### 原始音节表（Syllabary）

```
['zhang', 'shang', 'chang', 'zhuang', 'shuang', ...]
```

### 初始 Script 状态

```cpp
Script = {
  'zhang': [{str:'zhang'}],
  'shang': [{str:'shang'}],
  'chang': [{str:'chang'}],
  'zhuang': [{str:'zhuang'}],
  ...
}
```

---

## 阶段一：xform 规则应用

### 规则 1: `xform/^zh/Ⓥ/`

**作用**：将声母 `zh` 替换为临时符号 `Ⓥ`

**代码执行**（Transformation::Apply）：

```cpp
// 输入: spelling->str = "zhang"
// pattern_ = "^zh", replacement_ = "Ⓥ"

string result = boost::regex_replace("zhang", pattern_, replacement_);
// result = "Ⓥang"

spelling->str = "Ⓥang";
return true;  // 修改成功
```

**Script 状态更新**（Projection::Apply）：

```cpp
// 原映射被替换
Script = {
  'Ⓥang': [{str:'zhang'}],  // 键变了，值保持原音节
  'shang': [{str:'shang'}],
  'chang': [{str:'chang'}],
  ...
}
```

**关键点**：
- xform **不是 addition 类型**，会**删除原映射**
- 键从 `'zhang'` 变为 `'Ⓥang'`
- 值仍然是原音节 `'zhang'`（用于后续查词典）

### 规则 2: `xform/ang(\d)$/Ⓢ$1/`

**作用**：将韵母 `ang` + 声调替换为 `Ⓢ` + 声调

**代码执行**：

```cpp
// 输入: spelling->str = "Ⓥang1"
// pattern_ = "ang(\d)$", replacement_ = "Ⓢ$1"

string result = boost::regex_replace("Ⓥang1", pattern_, replacement_);
// result = "ⓋⓈ1"

spelling->str = "ⓋⓈ1";
```

**Script 状态更新**：

```cpp
Script = {
  'ⓋⓈ1': [{str:'zhang'}],  // 键再次变化
  'shang': [{str:'shang'}],
  ...
}
```

### 其他音节的类似转换

| 原音节 | 经过 xform 后的键 | 值（实际音节） |
|--------|------------------|---------------|
| zhang1 | ⓋⓈ1 | zhang |
| shang1 | ⓊⓈ1 | shang |
| chang1 | ⓘⓈ1 | chang |
| zhuang1 | ⓋⓄ1 | zhuang |
| shuang1 | ⓊⓄ1 | shuang |
| iang1 | ⓓ1 | iang |
| uang1 | ⓓ1 | uang |

**注意**：`iang` 和 `uang` 都会被转换为 `ⓓ1`（键相同），它们的值会被合并：

```cpp
Script = {
  'ⓓ1': [{str:'iang'}, {str:'uang'}],  // 一个键对应多个音节
  ...
}
```

---

## 阶段二：xlit 规则应用

### 规则: `xlit/ⓆⓌⓇⓉⓎⓊⒾⓄⓅⓈⒹⒻⒼⒽⓂⒿⒸⓀⓁⓏⓍⓋⒷⓃ/qwrtyuiopsdfghmjcklzxvbn/`

**作用**：批量字符替换（音译）

**代码执行**（Transliteration::Apply）：

**文件**：`src/rime/algo/calculus.cc:69-94`

```cpp
bool Transliteration::Apply(Spelling* spelling) {
  // 输入: spelling->str = "ⓋⓈ1"
  
  // char_map_ = {
  //   'Ⓥ': 'v',
  //   'Ⓢ': 's',
  //   'Ⓤ': 'u',
  //   'Ⓘ': 'i',
  //   ...
  // }
  
  const char* p = spelling->str.c_str();
  char buffer[256] = "";
  char* q = buffer;
  uint32_t c;
  
  while ((c = utf8::unchecked::next(p))) {
    // 第一次循环: c = 'Ⓥ'
    if (char_map_.find(c) != char_map_.end()) {
      c = char_map_[c];  // c = 'v'
    }
    q = utf8::unchecked::append(c, q);
    
    // 第二次循环: c = 'Ⓢ'
    // c = char_map_['Ⓢ'] = 's'
    
    // 第三次循环: c = '1'
    // char_map_ 中没有 '1'，保持不变
  }
  
  // buffer = "vs1"
  spelling->str.assign(buffer);
  return true;
}
```

**Script 状态更新**：

```cpp
Script = {
  'vs1': [{str:'zhang'}],   // 键从 ⓋⓈ1 变为 vs1
  'us1': [{str:'shang'}],
  'is1': [{str:'chang'}],
  'vo1': [{str:'zhuang'}],
  'uo1': [{str:'shuang'}],
  'd1': [{str:'iang'}, {str:'uang'}],  // 合并项
  ...
}
```

---

## 阶段三：构建 Prism 音节图

### 1. 构建 Trie 树

**文件**：`src/rime/dict/prism.cc:134-147`

```cpp
vector<const char*> keys;
for (auto it = script->begin(); it != script->end(); ++it) {
  keys.push_back(it->first.c_str());
}
// keys = ["vs1", "us1", "is1", "vo1", "uo1", "d1", ...]

trie_->build(num_spellings, &keys[0]);
// 构建双数组 Trie，支持快速前缀匹配
```

### 2. 构建 spelling_map

**文件**：`src/rime/dict/prism.cc:194-223`

```cpp
// 1. 建立音节ID映射
map<string, SyllableId> syllable_to_id;
SyllableId syll_id = 0;
for (auto it = syllabary.begin(); it != syllabary.end(); ++it) {
  syllable_to_id[*it] = syll_id++;
}
// syllable_to_id = {
//   'zhang': 0,
//   'shang': 1,
//   'chang': 2,
//   'zhuang': 3,
//   'shuang': 4,
//   'iang': 5,
//   'uang': 6,
//   ...
// }

// 2. 为每个键构建音节描述符列表
auto spelling_map = CreateArray<SpellingMapItem>(num_spellings);
auto i = script->begin();
auto item = spelling_map->begin();

for (; i != script->end(); ++i, ++item) {
  // 例如: i->first = "vs1", i->second = [{str:'zhang'}]
  
  size_t list_size = i->second.size();  // 1
  item->size = list_size;
  item->at = Allocate<SpellingDescriptor>(list_size);
  
  auto j = i->second.begin();
  auto desc = item->begin();
  for (; j != i->second.end(); ++j, ++desc) {
    desc->syllable_id = syllable_to_id[j->str];  // 0 (zhang)
    desc->type = j->properties.type;             // kNormalSpelling
    desc->credibility = j->properties.credibility;  // 0.0
  }
}
```

**最终 spelling_map 结构**：

```cpp
spelling_map = {
  "vs1" -> [
    {syllable_id: 0, type: normal, credibility: 0.0}  // zhang
  ],
  "us1" -> [
    {syllable_id: 1, type: normal, credibility: 0.0}  // shang
  ],
  "d1" -> [
    {syllable_id: 5, type: normal, credibility: 0.0},  // iang
    {syllable_id: 6, type: normal, credibility: 0.0}   // uang
  ],
  ...
}
```

---

## 运行期查询流程

### 用户输入 "vs1"

#### 1. Trie 树查询

```cpp
Prism::CommonPrefixSearch("vs1", &result);
// 返回: [{value: spelling_id_of_vs1, length: 3}]
```

#### 2. 查询音节映射

```cpp
SpellingAccessor accessor = prism->QuerySpelling(spelling_id_of_vs1);

while (!accessor.exhausted()) {
  SyllableId syll_id = accessor.syllable_id();  // 0
  // 通过 syll_id = 0 查词典，找到所有包含 'zhang' 的词条
  
  accessor.Next();
}
```

#### 3. 词典查询

```cpp
// 使用 syllable_id = 0 (对应 'zhang') 查询词典
// 返回: ["张", "章", "长", "涨", ...]
```

### 用户输入 "d1"（多音节匹配）

```cpp
SpellingAccessor accessor = prism->QuerySpelling(spelling_id_of_d1);

// 第一次迭代
accessor.syllable_id();  // 5 (iang)
// 查词典: ["将", "江", "讲", ...]

accessor.Next();

// 第二次迭代
accessor.syllable_id();  // 6 (uang)
// 查词典: ["王", "往", "网", ...]
```

---

## 关键技术点

### 1. xform vs derive 的区别

| 特性 | xform | derive |
|------|-------|--------|
| 原映射 | **删除** | **保留** |
| 新映射 | 创建 | 创建 |
| addition() | false | true |
| deletion() | true | false |
| 用途 | 音节转换 | 模糊音、容错 |

**代码体现**（Projection::Apply）：

```cpp
if (applied) {
  if (!x->deletion()) {
    // derive: 保留原映射
    temp.Merge(v.first, SpellingProperties(), v.second);
  }
  if (x->addition() && !s.str.empty()) {
    // derive 和 xform 都会执行这里
    temp.Merge(s.str, s.properties, v.second);
  }
}
```

### 2. xlit 的字符映射构建

**文件**：`src/rime/algo/calculus.cc:38-67`

```cpp
Calculation* Transliteration::Parse(const vector<string>& args) {
  const string& left(args[1]);   // "ⓆⓌⓇⓉ..."
  const string& right(args[2]);  // "qwrt..."
  
  map<uint32_t, uint32_t> char_map;
  const char* pl = left.c_str();
  const char* pr = right.c_str();
  uint32_t cl, cr;
  
  while ((cl = utf8::unchecked::next(pl))) {
    if (!(cr = utf8::unchecked::next(pr)))
      break;
    char_map[cl] = cr;
  }
  // char_map = {
  //   'Ⓠ': 'q', 'Ⓦ': 'w', 'Ⓡ': 'r', 'Ⓣ': 't', ...
  // }
  
  the<Transliteration> x(new Transliteration);
  x->char_map_.swap(char_map);
  return x.release();
}
```

### 3. 多音节合并机制

当多个音节经过转换后得到相同的键时，Script::Merge 会自动合并：

```cpp
void Script::Merge(const string& s, 
                   const SpellingProperties& sp,
                   const vector<Spelling>& v) {
  vector<Spelling>& m((*this)[s]);  // 获取现有列表
  
  for (const Spelling& x : v) {
    auto e = std::find(m.begin(), m.end(), x);
    if (e == m.end()) {
      m.push_back(y);  // 添加新音节
    } else {
      // 已存在，更新属性（取更优的）
      if (yy.credibility > zz.credibility)
        zz.credibility = yy.credibility;
    }
  }
}
```

---

## 完整转换表示例

| 全拼 | xform 中间态 | xlit 最终键 | 说明 |
|------|-------------|------------|------|
| zhang1 | ⓋⓈ1 | vs1 | zh→Ⓥ, ang→Ⓢ |
| shang1 | ⓊⓈ1 | us1 | sh→Ⓤ, ang→Ⓢ |
| chang1 | ⓘⓈ1 | is1 | ch→Ⓘ, ang→Ⓢ |
| zhuang1 | ⓋⓄ1 | vo1 | zh→Ⓥ, uo→Ⓞ |
| iang1 | ⓓ1 | d1 | iang→Ⓓ |
| uang1 | ⓓ1 | d1 | uang→Ⓓ（合并） |
| ying1 | Ⓨⓖ1 | yg1 | y保持, ing→Ⓖ |
| ying1 | Ⓨing1 | Ying1 | 如果没有 ing 规则 |

---

## 调试技巧

### 1. 查看中间转换结果

在 `src/rime/algo/algebra.cc:124` 添加日志：

```cpp
for (an<Calculation>& x : calculation_) {
  ++round;
  DLOG(INFO) << "=== Round #" << round << " ===";
  
  Script temp;
  for (const Script::value_type& v : *value) {
    Spelling s(v.first);
    bool applied = x->Apply(&s);
    
    if (applied) {
      DLOG(INFO) << "  " << v.first << " -> " << s.str;  // 添加这行
    }
    // ...
  }
}
```

输出示例：
```
=== Round #1 ===
  zhang -> Ⓥang
  shang -> Ⓤang
=== Round #2 ===
  Ⓥang -> ⓋⓈ
  Ⓤang -> ⓊⓈ
=== Round #3 ===
  ⓋⓈ -> vs
  ⓊⓈ -> us
```

### 2. 导出 Script 内容

```bash
rime_deployer --build /path/to/user_data --dump
```

查看 `*.prism.txt`：
```
vs1	zhang	-	0	
us1	shang	-	0	
d1	iang	-	0	
d1	uang	-	0	
```

### 3. 测试单个规则

```cpp
TEST(AlgebraTest, DoublePin) {
  Script script;
  script.AddSyllable("zhang");
  script.AddSyllable("shang");
  
  Projection p;
  p.Load({
    "xform/^zh/Ⓥ/",
    "xform/^sh/Ⓤ/",
    "xform/ang$/Ⓢ/",
    "xlit/ⓋⓊⓈ/vus/"
  });
  p.Apply(&script);
  
  EXPECT_EQ(script.find("vs"), script.end());  // 原键已删除
  EXPECT_EQ(script["vs"][0].str, "zhang");     // 值保持不变
  EXPECT_EQ(script["us"][0].str, "shang");
}
```

---

## 性能优化要点

### 1. 规则顺序优化

- **先处理声母，再处理韵母**：避免重复匹配
- **从长到短匹配**：`uang` 应在 `ang` 之前，否则会被误匹配

### 2. 临时符号选择

- 使用 Unicode 特殊字符（Ⓤ Ⓘ Ⓥ）避免与拼音字母冲突
- 确保临时符号不会出现在用户输入中

### 3. 内存占用

- Script 在编译期构建，运行期不存在
- Prism 使用内存映射（mmap），按需加载
- spelling_map 采用紧凑的数组结构，减少指针开销

---

## 相关文件索引

| 功能 | 文件 | 关键函数 |
|------|------|----------|
| xform 实现 | `src/rime/algo/calculus.{h,cc}` | `Transformation::Apply` |
| xlit 实现 | `src/rime/algo/calculus.{h,cc}` | `Transliteration::Apply` |
| 规则应用 | `src/rime/algo/algebra.cc` | `Projection::Apply` |
| 音节合并 | `src/rime/algo/algebra.cc` | `Script::Merge` |
| Prism 构建 | `src/rime/dict/prism.cc` | `Prism::Build` |

---

## 总结

双拼方案的核心思想：

1. **xform 规则链**：将全拼逐步转换为双拼键位
2. **临时符号**：避免中间转换冲突
3. **xlit 批量替换**：最后统一转换为键盘按键
4. **音节合并**：多个全拼可能对应同一个双拼（如 `d` 对应 `iang` 和 `uang`）
5. **值保持不变**：键变化，但值始终是原音节，用于查词典

这种设计既保证了输入效率（双拼），又保持了词典的通用性（全拼音节）。
