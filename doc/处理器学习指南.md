# RIME 处理器学习指南

> 适用版本：librime 1.14.0+
> 更新时间：2025-10-26

## 1. 什么是 Processor？

在 RIME 输入引擎中，**Processor（处理器）**负责“第一时间”响应键盘事件。它们按顺序组成一条流水线，每个处理器都可以决定：
- **接受**（`kAccepted`）：消费此次按键，比如写入输入串、切换模式。
- **拒绝**（`kRejected`）：交给系统默认处理，常用于 ASCII 模式直接输出英文。
- **忽略**（`kNoop`）：自己不处理，留给后续处理器。

可以把它们想象成机场安检的多个关卡：行李（按键）会依次经过安检仪（Processor），只要有一道关卡接管，就不再往后传递。

```
按键 → lua_processor → ascii_composer → recognizer → key_binder → speller → punctuator → selector → navigator → express_editor → 系统默认
```

## 2. Lua 处理器：lua_processor@*select_character
- **源码**：`cmake-build-debug/bin/bim-pinyin/lua/select_character.lua`
- **功能**：按自定义快捷键（默认 `[` `]`）将当前候选拆成首字/末字直接上屏，完成“以词定字”。
- **生活类比**：像提前准备好的剪刀，可以随时把一个词剪出想要的字。

关键逻辑：
```lua
if 按键命中 && 有候选 then
  text = 当前候选文本
  if text 长度 > 1:
    commit(text 的首/末字)
  else:
    commit(text)
  clear()
  return 1 -- 消费按键
end
return 2 -- 交给下一个处理器
```

## 3. ASCII 模式切换器：ascii_composer
- **源码**：`src/rime/gear/ascii_composer.{h,cc}`
- **核心函数**：`AsciiComposer::ProcessKeyEvent`@ascii_composer.cc#60-140
- **功能**：
  1. 识别 Caps Lock、Shift 双击、Eisu 等组合键切换 ASCII 模式。
  2. 在 ASCII 模式下，如果没有正在输入的候选，直接返回 `kRejected` 让系统上屏英文。
  3. 在“临时英文”状态，将字符写入 Context 中的 `input`。
- **类比**：像门口保安决定当前这批字符走“中文通道”还是“英文通道”。

```cpp
if 是切换键:
  ToggleAsciiModeWithKey()
  return kAccepted
if 当前处于 ascii_mode 且没有在输入:
  return kRejected  // 让系统上屏英文
if ascii_mode 下正在输入:
  ctx->PushInput(ch)
  return kAccepted
return kNoop
```

## 4. 模式识别器：recognizer
- **源码**：`src/rime/gear/recognizer.{h,cc}`
- **核心函数**：`Recognizer::ProcessKeyEvent`@recognizer.cc#84-101
- **功能**：用正则匹配输入串，识别 `/`、`U`、`cC` 等特殊模式，对应符号表、Unicode、计算器等功能。
- **类比**：像安检的扫描仪识别特定“行李”，为其贴上标签。

```cpp
if (匹配正则 && 不是修饰键):
  ctx->PushInput(ch)
  return kAccepted
return kNoop
```

## 5. 按键绑定器：key_binder
- **源码**：`src/rime/gear/key_binder.{h,cc}`
- **核心函数**：`KeyBinder::ProcessKeyEvent`@key_binder.cc#240-330
- **功能**：将用户配置的键（例如 `Page_Up`、`Ctrl+Shift+4`）映射成命令，包含：
  - 翻页、选词
  - 切换选项或方案
  - 发送按键序列
- **类比**：像遥控器上的自定义按键，你可以定义“长按音量键打开设置”等动作。

```cpp
if 按键命中绑定:
  执行绑定的动作（toggle_option / select_schema / send_sequence）
  return kAccepted
return kNoop
```

## 6. 拼写器：speller
- **源码**：`src/rime/gear/speller.{h,cc}`
- **核心函数**：`Speller::ProcessKeyEvent`@speller.cc#100-145
- **功能**：
  1. 接收字母、分隔符等，写入 `Context::input`。
  2. 根据配置处理模糊音、最大编码长度、自动选词、自动清码。
- **类比**：像语文老师把拼音逐个写在黑板，并根据规则判断是否自动选字。

```cpp
if 无修饰键 && 字符合法:
  ctx->PushInput(ch)
  ctx->BeginEditing()
  自动选词 / 自动清除
  return kAccepted
return kNoop
```

## 7. 标点处理器：punctuator
- **源码**：`src/rime/gear/punctuator.{h,cc}`
- **核心函数**：`Punctuator::ProcessKeyEvent`@punctuator.cc#164-308
- **功能**：按配置将标点键转换为半角/全角、成对符号、自动翻转引号等。
- **类比**：像客服机器人，根据你的指令输出对应风格的标点符号。

## 8. 候选选择器：selector
- **源码**：`src/rime/gear/selector.{h,cc}`
- **核心函数**：`Selector::ProcessKeyEvent`@selector.cc#57-175
- **功能**：处理数字选词、上下翻页等操作。
- **类比**：像餐厅服务员，根据你的手势把菜单中的菜换到你面前或直接下单。

## 9. 游标导航器：navigator
- **源码**：`src/rime/gear/navigator.{h,cc}`
- **功能**：在输入串存在多个段时，处理左右方向键、Home/End 等，移动当前编辑位置。
- **类比**：像地图上的指南针，帮助你在多个拼音分段之间移动光标。

## 10. 快速编辑器：express_editor
- **源码**：`src/rime/gear/editor.{h,cc}`（`express_editor` 为默认别名）
- **功能**：处理 Enter、Escape、Backspace 等编辑类按键，用于确认、取消、清空候选。
- **类比**：像写字时的橡皮擦和回车键，帮你快速调整已输入内容。

## 11. 整体协作流程

1. **Lua 处理器**首先响应特殊快捷键（如“以词定字”）。
2. **ASCII Composer**判断是否进入英文模式。
3. **Recognizer**捕捉特定模式（网址、反查、计算器）。
4. **Key Binder**处理翻页、切换方案等自定义命令。
5. **Speller**把字母写入输入串。
6. **Punctuator**格式化标点。
7. **Selector**负责候选选择与翻页。
8. **Navigator**移动光标位置。
9. **Express Editor**管理回车、退格等编辑操作。

任何一个处理器返回 `kAccepted` 或 `kRejected`，该按键就不会继续传递；若全部 `kNoop`，最终回到操作系统默认行为。

## 12. 记忆口诀

> **“Lua 育英双控选，键谱标选游快编。”**
>
> - **Lua** → Lua 处理器
> - **育英**（语音）→ ASCII Composer、Recognizer、Speller
> - **双控** → Key Binder、Punctuator
> - **选** → Selector
> - **游** → Navigator
> - **快编** → Express Editor

## 13. 常见问题

### Q1. 想自定义快捷键应该改哪里？
修改 schema 中的 `key_binder/bindings`，或 Lua 脚本参数。

### Q2. 中文与英文切换逻辑在哪里？
`ascii_composer` 负责所有 ASCII 模式相关逻辑，包括 Caps Lock、Shift 双击。

### Q3. 输入 `/` 就直接弹出符号表是因为？
`recognizer` 检测到 `/` 对应的正则模式，并打上 `punct` 标签，后续的 `punctuator` 负责翻译。

### Q4. 为什么数字键没选中候选？
检查 `selector` 是否被前面处理器消费了按键；或检查 `key_binder` 是否将数字键映射到其他动作。

## 14. 调试技巧

1. **日志**：在源码中加 `DLOG(INFO)`，编译 Debug 版本，观察按键流向。
2. **rime_api_console**：构建后运行可查看实时状态。
3. **逐个禁用**：在 schema 中逐渐移除某些处理器，定位问题来源。

## 15. 相关源码汇总

| 模块 | 文件 |
|------|------|
| 基类 | `src/rime/processor.h` |
| Lua 处理器 | `cmake-build-debug/bin/bim-pinyin/lua/select_character.lua` |
| ASCII Composer | `src/rime/gear/ascii_composer.{h,cc}` |
| Recognizer | `src/rime/gear/recognizer.{h,cc}` |
| Key Binder | `src/rime/gear/key_binder.{h,cc}` |
| Speller | `src/rime/gear/speller.{h,cc}` |
| Punctuator | `src/rime/gear/punctuator.{h,cc}` |
| Selector | `src/rime/gear/selector.{h,cc}` |
| Navigator | `src/rime/gear/navigator.{h,cc}` |
| Express Editor | `src/rime/gear/editor.{h,cc}` |

## 16. 学习建议

1. 按照本文顺序再次阅读源码，重点关注 `ProcessKeyEvent` 函数，理解按键的“接力”过程。
2. 结合 `/doc/分段器学习指南.md`，整体把握 Processor、Segmentor、Translator、Filter 的协作关系。
3. 实践中可先在 schema 调整处理器顺序或配置，观察日志变化，再逐步深入源码层面的改动。

---

如需添加自定义 Processor，可参考 `processor.h` 定义，实现 `ProcessKeyEvent`，并在 `engine/processors` 中注册。祝学习顺利！
