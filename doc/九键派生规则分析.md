# 九键派生规则分析

## 规则概览

这是一个典型的**九键输入法**（T9输入法）的实现，将26个字母映射到9个数字键上：

```yaml
speller:
  algebra:
    - derive/[abc]/a/    # 2键: a,b,c → a
    - derive/[def]/d/    # 3键: d,e,f → d
    - derive/[ghi]/h/    # 4键: g,h,i → h  (注意是hgi不是ghi)
    - derive/[jkl]/j/    # 5键: j,k,l → j
    - derive/[mno]/o/    # 6键: m,n,o → o
    - derive/[pqrs]/p/   # 7键: p,q,r,s → p
    - derive/[tuv]/t/    # 8键: t,u,v → t
    - derive/[wxyz]/w/   # 9键: w,x,y,z → w
```

**核心思想**：用户按数字键时，可以匹配该键上的所有字母对应的音节。

---

## 标准九键布局

```
┌─────┬─────┬─────┐
│  1  │  2  │  3  │
│     │ ABC │ DEF │
├─────┼─────┼─────┤
│  4  │  5  │  6  │
│ GHI │ JKL │ MNO │
├─────┼─────┼─────┤
│  7  │  8  │  9  │
│PQRS │ TUV │WXYZ │
└─────┴─────┴─────┘
```

**注意**：配置中的 `[hgi]` 应该是笔误，标准应该是 `[ghi]`。

---

## 完整示例：音节 "hao" 的派生过程

### 原始音节表（Syllabary）

```
['hao', 'bao', 'cao', 'dao', 'gao', 'kao', 'lao', ...]
```

### 初始 Script 状态

```cpp
Script = {
  'hao': [{str:'hao'}],
  'bao': [{str:'bao'}],
  'cao': [{str:'cao'}],
  'dao': [{str:'dao'}],
  'gao': [{str:'gao'}],
  'kao': [{str:'kao'}],
  'lao': [{str:'lao'}],
  ...
}
```

---

## 阶段一：应用第一条规则 `derive/[abc]/a/`

### 规则含义

- **pattern**: `[abc]` - 匹配字母 a、b 或 c
- **replacement**: `a` - 替换为字母 a
- **derive**: 保留原映射，创建新映射

### 代码执行过程

#### 1. 遍历 Script 中的每个音节

**处理 "hao"**：

```cpp
Spelling s("hao");
bool applied = Derivation::Apply(&s);

// Transformation::Apply 内部
string result = boost::regex_replace("hao", pattern_, replacement_);
// pattern_ = "[abc]", replacement_ = "a"
// result = "hao" (没有匹配到 a/b/c)
// return false;
```

**Script 更新**：
```cpp
// applied = false，保留原映射
temp.Merge("hao", SpellingProperties(), [{"hao"}]);
// temp["hao"] = [{str:"hao"}]
```

**处理 "bao"**：

```cpp
Spelling s("bao");
bool applied = Derivation::Apply(&s);

// Transformation::Apply 内部
string result = boost::regex_replace("bao", "[abc]", "a");
// result = "aao" (b 被替换为 a)
// s.str = "aao"
// return true;
```

**Script 更新**（Projection::Apply）：

```cpp
// applied = true
if (!x->deletion()) {
  // derive 不删除原映射
  temp.Merge("bao", SpellingProperties(), [{str:"bao"}]);
  // temp["bao"] = [{str:"bao"}]
}

if (x->addition() && !s.str.empty()) {
  // derive 是 addition 类型，添加新映射
  temp.Merge("aao", s.properties, [{str:"bao"}]);
  // temp["aao"] = [{str:"bao"}]  ← 关键！
}
```

**处理 "cao"**：

```cpp
Spelling s("cao");
bool applied = Derivation::Apply(&s);

// result = "aao" (c 被替换为 a)
// s.str = "aao"
// return true;
```

**Script 更新**：

```cpp
// 原映射
temp["cao"] = [{str:"cao"}]

// 新映射（与 bao 合并）
temp.Merge("aao", s.properties, [{str:"cao"}]);
// temp["aao"] = [{str:"bao"}, {str:"cao"}]  ← 合并！
```

### 第一条规则应用后的 Script 状态

```cpp
Script = {
  'hao': [{str:'hao'}],
  'bao': [{str:'bao'}],
  'cao': [{str:'cao'}],
  'aao': [{str:'bao'}, {str:'cao'}],  // 新增派生项
  'dao': [{str:'dao'}],
  'gao': [{str:'gao'}],
  'kao': [{str:'kao'}],
  'lao': [{str:'lao'}],
  ...
}
```

---

## 阶段二：应用第二条规则 `derive/[def]/d/`

### 处理 "dao"

```cpp
Spelling s("dao");
bool applied = Derivation::Apply(&s);

// result = "dao" (d 替换为 d，没有变化)
// return false;
```

**Script 更新**：
```cpp
// 保留原映射
temp["dao"] = [{str:"dao"}]
```

**注意**：虽然 `d` 匹配了 `[def]`，但替换后还是 `d`，所以 `result == spelling->str`，返回 `false`。

### 处理 "eao"（如果存在）

```cpp
Spelling s("eao");
bool applied = Derivation::Apply(&s);

// result = "dao" (e 被替换为 d)
// return true;
```

**Script 更新**：
```cpp
temp["eao"] = [{str:"eao"}]  // 原映射
temp["dao"] = [{str:"eao"}]  // 新映射
```

### 处理 "aao"（派生项）

```cpp
// 当前 "aao" 对应 [{str:"bao"}, {str:"cao"}]

Spelling s("aao");
bool applied = Derivation::Apply(&s);

// result = "aao" (没有匹配到 d/e/f)
// return false;
```

**Script 更新**：
```cpp
// 保留原映射
temp["aao"] = [{str:"bao"}, {str:"cao"}]
```

---

## 阶段三：应用第三条规则 `derive/[ghi]/h/`

**注意**：配置中是 `[hgi]`，但标准应该是 `[ghi]`，我们按标准分析。

### 处理 "hao"

```cpp
Spelling s("hao");
bool applied = Derivation::Apply(&s);

// result = "hao" (h 替换为 h，没有变化)
// return false;
```

**Script 更新**：
```cpp
temp["hao"] = [{str:"hao"}]  // 保留原映射
```

### 处理 "gao"

```cpp
Spelling s("gao");
bool applied = Derivation::Apply(&s);

// result = "hao" (g 被替换为 h)
// return true;
```

**Script 更新**：
```cpp
temp["gao"] = [{str:"gao"}]  // 原映射
temp.Merge("hao", s.properties, [{str:"gao"}]);
// temp["hao"] = [{str:"hao"}, {str:"gao"}]  ← 合并！
```

### 处理 "iao"（如果存在）

```cpp
Spelling s("iao");
bool applied = Derivation::Apply(&s);

// result = "hao" (i 被替换为 h)
// return true;
```

**Script 更新**：
```cpp
temp["iao"] = [{str:"iao"}]  // 原映射
temp.Merge("hao", s.properties, [{str:"iao"}]);
// temp["hao"] = [{str:"hao"}, {str:"gao"}, {str:"iao"}]  ← 再次合并！
```

---

## 阶段四：应用第四条规则 `derive/[jkl]/j/`

### 处理 "kao"

```cpp
Spelling s("kao");
bool applied = Derivation::Apply(&s);

// result = "jao" (k 被替换为 j)
// return true;
```

**Script 更新**：
```cpp
temp["kao"] = [{str:"kao"}]  // 原映射
temp["jao"] = [{str:"kao"}]  // 新映射
```

### 处理 "lao"

```cpp
Spelling s("lao");
bool applied = Derivation::Apply(&s);

// result = "jao" (l 被替换为 j)
// return true;
```

**Script 更新**：
```cpp
temp["lao"] = [{str:"lao"}]  // 原映射
temp.Merge("jao", s.properties, [{str:"lao"}]);
// temp["jao"] = [{str:"kao"}, {str:"lao"}]  ← 合并！
```

---

## 阶段五：应用剩余规则

### `derive/[mno]/o/`

```cpp
// mao → oao
// nao → oao
// oao → oao (无变化)

Script["oao"] = [{str:"mao"}, {str:"nao"}]
```

### `derive/[pqrs]/p/`

```cpp
// pao → pao (无变化)
// qao → pao
// rao → pao
// sao → pao

Script["pao"] = [{str:"pao"}, {str:"qao"}, {str:"rao"}, {str:"sao"}]
```

### `derive/[tuv]/t/`

```cpp
// tao → tao (无变化)
// uao → tao (如果存在)
// vao → tao (如果存在)

Script["tao"] = [{str:"tao"}]
```

### `derive/[wxyz]/w/`

```cpp
// wao → wao (无变化)
// xao → wao (如果存在)
// yao → wao
// zao → wao

Script["wao"] = [{str:"wao"}, {str:"yao"}, {str:"zao"}]
```

---

## 最终 Script 状态

```cpp
Script = {
  // 原始映射（保留）
  'hao': [{str:'hao'}, {str:'gao'}, {str:'iao'}],  // 4键
  'bao': [{str:'bao'}],
  'cao': [{str:'cao'}],
  'dao': [{str:'dao'}],
  'gao': [{str:'gao'}],
  'kao': [{str:'kao'}],
  'lao': [{str:'lao'}],
  'mao': [{str:'mao'}],
  'nao': [{str:'nao'}],
  'pao': [{str:'pao'}, {str:'qao'}, {str:'rao'}, {str:'sao'}],  // 7键
  'tao': [{str:'tao'}],
  'yao': [{str:'yao'}],
  'zao': [{str:'zao'}],
  
  // 派生映射（新增）
  'aao': [{str:'bao'}, {str:'cao'}],               // 2键
  'jao': [{str:'kao'}, {str:'lao'}],               // 5键
  'oao': [{str:'mao'}, {str:'nao'}],               // 6键
  'wao': [{str:'wao'}, {str:'yao'}, {str:'zao'}],  // 9键
  ...
}
```

---

## 构建 Prism 音节图

### 1. 构建 Trie 树

```cpp
vector<const char*> keys;
for (auto it = script->begin(); it != script->end(); ++it) {
  keys.push_back(it->first.c_str());
}
// keys = ["hao", "bao", "cao", "aao", "dao", "jao", "oao", "pao", "wao", ...]

trie_->build(num_spellings, &keys[0]);
```

### 2. 构建 spelling_map

```cpp
// 音节ID映射
syllable_to_id = {
  'hao': 0, 'bao': 1, 'cao': 2, 'dao': 3,
  'gao': 4, 'iao': 5, 'kao': 6, 'lao': 7,
  'mao': 8, 'nao': 9, 'pao': 10, 'qao': 11,
  'rao': 12, 'sao': 13, 'tao': 14, 'yao': 15,
  'zao': 16, ...
}

// spelling_map 构建
spelling_map = {
  "hao" -> [
    {syllable_id: 0, type: normal},  // hao
    {syllable_id: 4, type: normal},  // gao
    {syllable_id: 5, type: normal}   // iao
  ],
  "aao" -> [
    {syllable_id: 1, type: normal},  // bao
    {syllable_id: 2, type: normal}   // cao
  ],
  "jao" -> [
    {syllable_id: 6, type: normal},  // kao
    {syllable_id: 7, type: normal}   // lao
  ],
  "oao" -> [
    {syllable_id: 8, type: normal},  // mao
    {syllable_id: 9, type: normal}   // nao
  ],
  "pao" -> [
    {syllable_id: 10, type: normal},  // pao
    {syllable_id: 11, type: normal},  // qao
    {syllable_id: 12, type: normal},  // rao
    {syllable_id: 13, type: normal}   // sao
  ],
  ...
}
```

---

## 运行期查询流程

### 用户输入 "hao"（按 4-2-6 键）

#### 1. Trie 树查询

```cpp
Prism::CommonPrefixSearch("hao", &result);
// 返回: [{value: spelling_id_of_hao, length: 3}]
```

#### 2. 查询音节映射

```cpp
SpellingAccessor accessor = prism->QuerySpelling(spelling_id_of_hao);

// 第一次迭代
accessor.syllable_id();  // 0 (hao)
// 查词典: ["好", "号", "豪", ...]

accessor.Next();

// 第二次迭代
accessor.syllable_id();  // 4 (gao)
// 查词典: ["高", "搞", "告", ...]

accessor.Next();

// 第三次迭代
accessor.syllable_id();  // 5 (iao)
// 查词典: ["要", "药", "腰", ...]
```

**结果**：用户输入 `hao`，可以匹配到 `hao`、`gao`、`iao` 三个音节的所有词条。

### 用户输入 "aao"（按 2-2-6 键）

```cpp
SpellingAccessor accessor = prism->QuerySpelling(spelling_id_of_aao);

// 第一次迭代
accessor.syllable_id();  // 1 (bao)
// 查词典: ["包", "报", "抱", ...]

accessor.Next();

// 第二次迭代
accessor.syllable_id();  // 2 (cao)
// 查词典: ["草", "操", "曹", ...]
```

**结果**：用户输入 `aao`，可以匹配到 `bao`、`cao` 两个音节的所有词条。

---

## 九键输入的完整映射表

| 数字键 | 字母 | 代表字母 | 示例音节 | 派生键 |
|--------|------|----------|----------|--------|
| 2 | ABC | a | bao, cao | aao |
| 3 | DEF | d | eao, fao | dao |
| 4 | GHI | h | gao, iao | hao |
| 5 | JKL | j | kao, lao | jao |
| 6 | MNO | o | mao, nao | oao |
| 7 | PQRS | p | qao, rao, sao | pao |
| 8 | TUV | t | uao, vao | tao |
| 9 | WXYZ | w | xao, yao, zao | wao |

---

## 实际输入示例

### 输入 "好" (hao)

用户按键：`4-2-6`（对应 h-a-o）

**查询过程**：
1. Trie 查找 `hao`
2. 返回音节：`hao`, `gao`, `iao`
3. 查词典，候选词：
   - hao: 好、号、豪、耗...
   - gao: 高、搞、告、膏...
   - iao: 要、药、腰、咬...

### 输入 "包" (bao)

用户按键：`2-2-6`（对应 b-a-o，但 b 在 2 键上）

**查询过程**：
1. 实际输入：`aao`（因为 b → a）
2. Trie 查找 `aao`
3. 返回音节：`bao`, `cao`
4. 查词典，候选词：
   - bao: 包、报、抱、爆...
   - cao: 草、操、曹、槽...

### 输入 "高兴" (gaoxing)

用户按键：`4-2-6-9-4-6-4`

**第一个音节 "gao"**：
- 输入：`hao`（g → h）
- 匹配：hao, gao, iao

**第二个音节 "xing"**：
- 输入：`wh...`（x → w, i → h）
- 匹配：xing, ying, zing, wing, hing...

---

## 关键技术点

### 1. derive 规则的特性

| 特性 | 值 | 说明 |
|------|-----|------|
| addition() | true | 创建新映射 |
| deletion() | false | 保留原映射 |
| 原键 | 保留 | `bao` 仍然存在 |
| 新键 | 创建 | `aao` 被创建 |

### 2. 正则表达式字符类

```cpp
// pattern_ = "[abc]"
// 匹配单个字符：a 或 b 或 c

boost::regex_replace("bao", "[abc]", "a");
// 结果: "aao" (只替换第一个匹配的字符)

boost::regex_replace("cab", "[abc]", "a");
// 结果: "aab" (c 被替换为 a)

boost::regex_replace("abc", "[abc]", "a");
// 结果: "aac" (只替换第一个 a，b 被替换为 a)
```

### 3. 多音节合并

当多个音节派生到同一个键时，Script::Merge 自动合并：

```cpp
void Script::Merge(const string& s,
                   const SpellingProperties& sp,
                   const vector<Spelling>& v) {
  vector<Spelling>& m((*this)[s]);
  
  for (const Spelling& x : v) {
    auto e = std::find(m.begin(), m.end(), x);
    if (e == m.end()) {
      m.push_back(y);  // 添加新音节
    }
  }
}
```

### 4. 为什么某些字母替换为自己？

```yaml
- derive/[def]/d/   # d → d (无变化)
- derive/[ghi]/h/   # h → h (无变化)
```

**原因**：
- 虽然 `d` 替换为 `d` 没有变化，但 `e` 和 `f` 会被替换为 `d`
- 这样 `dao`、`eao`、`fao` 都会映射到 `dao`
- 保持规则的一致性和完整性

---

## 优化建议

### 1. 修正配置错误

```yaml
# 错误
- derive/[hgi]/h/

# 正确
- derive/[ghi]/h/
```

### 2. 添加声调支持

```yaml
speller:
  algebra:
    # 先去除声调
    - derive/([1-5])$//
    
    # 再应用九键派生
    - derive/[abc]/a/
    - derive/[def]/d/
    # ...
```

### 3. 优化候选词排序

```yaml
translator:
  initial_quality: 1.0
  
# 为派生音节降低权重
speller:
  algebra:
    - derive/[abc]/a/
    # 可以在 Filter 中根据 spelling type 调整权重
```

---

## 调试技巧

### 1. 查看派生结果

```bash
rime_deployer --build /path/to/user_data --dump
```

查看 `*.prism.txt`：
```
hao	hao	-	0	
hao	gao	-	0	← 派生项
hao	iao	-	0	← 派生项
aao	bao	-	0	← 派生项
aao	cao	-	0	← 派生项
```

### 2. 测试单个规则

```cpp
TEST(AlgebraTest, T9Derivation) {
  Script script;
  script.AddSyllable("bao");
  script.AddSyllable("cao");
  script.AddSyllable("hao");
  
  Projection p;
  p.Load({"derive/[abc]/a/"});
  p.Apply(&script);
  
  // 原映射保留
  EXPECT_EQ(script["bao"].size(), 1);
  EXPECT_EQ(script["bao"][0].str, "bao");
  
  // 新映射创建
  EXPECT_EQ(script["aao"].size(), 2);
  EXPECT_EQ(script["aao"][0].str, "bao");
  EXPECT_EQ(script["aao"][1].str, "cao");
  
  // hao 不受影响
  EXPECT_EQ(script["hao"].size(), 1);
  EXPECT_EQ(script["hao"][0].str, "hao");
}
```

### 3. 添加日志

在 `src/rime/algo/algebra.cc:136` 添加：

```cpp
if (applied) {
  DLOG(INFO) << "Derived: " << v.first << " -> " << s.str
             << " (syllable: " << v.second[0].str << ")";
}
```

输出示例：
```
Derived: bao -> aao (syllable: bao)
Derived: cao -> aao (syllable: cao)
Derived: gao -> hao (syllable: gao)
```

---

## 与双拼方案的对比

| 特性 | 双拼方案 | 九键方案 |
|------|----------|----------|
| 规则类型 | xform (变换) | derive (派生) |
| 原映射 | 删除 | 保留 |
| 一对多 | 否 | 是 |
| 临时符号 | 需要 | 不需要 |
| 用途 | 音节转换 | 模糊匹配 |
| 候选词数量 | 少 | 多 |

**双拼示例**：
```yaml
- xform/^zh/v/   # zhang → vang (原键删除)
```

**九键示例**：
```yaml
- derive/[abc]/a/  # bao → aao (原键保留)
```

---

## 总结

### 九键派生的核心机制

1. **保留原映射**：所有原音节键仍然可用（如 `bao`、`cao`）
2. **创建派生键**：为同一按键的字母创建统一的派生键（如 `aao`）
3. **多音节合并**：派生键对应多个原音节（如 `aao` → `bao`, `cao`）
4. **模糊匹配**：用户输入派生键时，匹配所有对应的音节

### 工作流程

```
原音节: bao, cao, hao, gao
  ↓ derive/[abc]/a/
派生: aao → [bao, cao]
保留: bao, cao, hao, gao
  ↓ derive/[ghi]/h/
派生: hao → [hao, gao]
保留: 所有原键 + aao

最终: 用户可以用 hao 匹配 hao 和 gao
      用户可以用 aao 匹配 bao 和 cao
```

### 适用场景

- **九键手机输入法**：数字键盘输入拼音
- **模糊音输入**：不区分某些字母（如 n/l 不分）
- **容错输入**：允许用户输入不精确的拼音

九键派生是 derive 规则的典型应用，体现了 librime 拼写代数的强大灵活性！
