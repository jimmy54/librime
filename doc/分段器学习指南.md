# RIME Segmentors å­¦ä¹ æŒ‡å—

## ğŸ“š ä»€ä¹ˆæ˜¯ Segmentor?

**Segmentor(åˆ†æ®µå™¨)** æ˜¯ RIME è¾“å…¥å¼•æ“ä¸­çš„æ ¸å¿ƒç»„ä»¶,è´Ÿè´£å°†ç”¨æˆ·çš„è¾“å…¥å­—ç¬¦ä¸²**åˆ‡åˆ†æˆä¸åŒçš„æ®µè½(Segment)**,æ¯ä¸ªæ®µè½ä¼šè¢«æ‰“ä¸Šä¸åŒçš„**æ ‡ç­¾(tag)**,ç„¶åäº¤ç»™ç›¸åº”çš„ Translator(ç¿»è¯‘å™¨)å¤„ç†ã€‚

### ç”Ÿæ´»ä¸­çš„ç±»æ¯”

æƒ³è±¡ä½ åœ¨è¶…å¸‚è´­ç‰©:
- **è¾“å…¥å­—ç¬¦ä¸²** = ä½ çš„è´­ç‰©è½¦é‡Œæ··æ”¾ç€å„ç§å•†å“
- **Segmentor** = æ”¶é“¶å‘˜,è´Ÿè´£æŠŠå•†å“åˆ†ç±»
- **Segment** = åˆ†ç±»åçš„å•†å“å †(æ°´æœã€é›¶é£Ÿã€æ—¥ç”¨å“ç­‰)
- **Tag** = å•†å“ç±»åˆ«æ ‡ç­¾
- **Translator** = ä¸åŒæŸœå°çš„ä¸“ä¸šäººå‘˜,å¤„ç†å„è‡ªç±»åˆ«çš„å•†å“

---

## ğŸ—ï¸ Segmentor çš„å·¥ä½œåŸç†

### 1. åŸºç¡€æ¶æ„

æ‰€æœ‰ Segmentor éƒ½ç»§æ‰¿è‡ªåŸºç±» `Segmentor`:

```cpp
// src/rime/segmentor.h
class Segmentor {
 public:
  // æ ¸å¿ƒæ–¹æ³•:å¤„ç†åˆ†æ®µ
  virtual bool Proceed(Segmentation* segmentation) = 0;
  
 protected:
  Engine* engine_;      // è¾“å…¥å¼•æ“
  string name_space_;   // é…ç½®å‘½åç©ºé—´
};
```

**è¿”å›å€¼å«ä¹‰**:
- `true`: ç»§ç»­æ‰§è¡Œä¸‹ä¸€ä¸ª Segmentor
- `false`: åœæ­¢æœ¬è½®åˆ†æ®µ,ä¸å†è°ƒç”¨åç»­çš„ Segmentor

### 2. æ‰§è¡Œæµç¨‹

Segmentors æŒ‰ç…§é…ç½®æ–‡ä»¶ä¸­çš„**é¡ºåºä¾æ¬¡æ‰§è¡Œ**,å°±åƒæµæ°´çº¿:

```yaml
segmentors:
  - ascii_segmentor      # ç¬¬1ä¸ªæ‰§è¡Œ
  - matcher              # ç¬¬2ä¸ªæ‰§è¡Œ
  - abc_segmentor        # ç¬¬3ä¸ªæ‰§è¡Œ
  - affix_segmentor      # ç¬¬4ä¸ªæ‰§è¡Œ
  - punct_segmentor      # ç¬¬5ä¸ªæ‰§è¡Œ
  - fallback_segmentor   # æœ€åæ‰§è¡Œ
```

æ¯ä¸ª Segmentor å¯ä»¥:
1. æ£€æŸ¥å½“å‰è¾“å…¥
2. æ·»åŠ æ–°çš„ Segment
3. å†³å®šæ˜¯å¦ç»§ç»­æ‰§è¡Œåç»­ Segmentor

---

## ğŸ“¦ å…­å¤§ Segmentor è¯¦è§£

### 1ï¸âƒ£ AsciiSegmentor - ASCII æ¨¡å¼åˆ†æ®µå™¨

**ä½œç”¨**: å½“å¼€å¯ ASCII æ¨¡å¼æ—¶,å°†æ•´ä¸ªè¾“å…¥æ ‡è®°ä¸ºåŸå§‹å­—ç¬¦,ç›´æ¥è¾“å‡ºè‹±æ–‡ã€‚

**æºç ä½ç½®**: `src/rime/gear/ascii_segmentor.cc`

**æ ¸å¿ƒé€»è¾‘**:
```cpp
bool AsciiSegmentor::Proceed(Segmentation* segmentation) {
  // æ£€æŸ¥æ˜¯å¦å¼€å¯äº† ASCII æ¨¡å¼
  if (!engine_->context()->get_option("ascii_mode"))
    return true;  // æœªå¼€å¯,ç»§ç»­ä¸‹ä¸€ä¸ª Segmentor
  
  // å¼€å¯äº† ASCII æ¨¡å¼,å°†æ•´ä¸ªè¾“å…¥æ ‡è®°ä¸º "raw"
  const string& input = segmentation->input();
  size_t j = segmentation->GetCurrentStartPosition();
  if (j < input.length()) {
    Segment segment(j, input.length());
    segment.tags.insert("raw");  // æ‰“ä¸Š "raw" æ ‡ç­¾
    segmentation->AddSegment(segment);
  }
  return false;  // åœæ­¢åç»­ Segmentor
}
```

**ä½¿ç”¨åœºæ™¯**:
- è¾“å…¥: `hello` (åœ¨ ASCII æ¨¡å¼ä¸‹)
- ç»“æœ: æ•´ä¸ª `hello` è¢«æ ‡è®°ä¸º `raw`,ç›´æ¥è¾“å‡ºè‹±æ–‡

**é…ç½®**: é€šè¿‡ `Shift` é”®åˆ‡æ¢ `ascii_mode` å¼€å…³

---

### 2ï¸âƒ£ Matcher - æ¨¡å¼åŒ¹é…åˆ†æ®µå™¨

**ä½œç”¨**: æ ¹æ®æ­£åˆ™è¡¨è¾¾å¼æ¨¡å¼åŒ¹é…ç‰¹æ®Šè¾“å…¥,å¦‚ç½‘å€ã€è®¡ç®—å™¨ã€Unicode ç­‰ã€‚

**æºç ä½ç½®**: `src/rime/gear/matcher.cc`

**æ ¸å¿ƒé€»è¾‘**:
```cpp
bool Matcher::Proceed(Segmentation* segmentation) {
  if (patterns_.empty())
    return true;
  
  // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…è¾“å…¥
  auto match = patterns_.GetMatch(segmentation->input(), *segmentation);
  if (match.found()) {
    // åŒ¹é…æˆåŠŸ,åˆ›å»ºå¯¹åº”çš„ Segment
    Segment segment(match.start, match.end);
    segment.tags.insert(match.tag);  // æ‰“ä¸ŠåŒ¹é…çš„æ ‡ç­¾
    segmentation->AddSegment(segment);
  }
  return true;  // ç»§ç»­ä¸‹ä¸€ä¸ª Segmentor
}
```

**é…ç½®ç¤ºä¾‹** (æ¥è‡ª `rime_ice_26.schema.yaml`):
```yaml
recognizer:
  patterns:
    punct: "^v([0-9]|10|[A-Za-z]+)$"        # v å¼€å¤´è§¦å‘ç¬¦å·
    radical_lookup: "^uU[a-z]+$"            # uU å¼€å¤´è§¦å‘éƒ¨ä»¶æ‹†å­—
    unicode: "^U[a-f0-9]+"                  # U å¼€å¤´è§¦å‘ Unicode
    number: "^R[0-9]+[.]?[0-9]*"            # R å¼€å¤´è§¦å‘æ•°å­—å¤§å†™
    calculator: "^cC.+"                     # cC å¼€å¤´è§¦å‘è®¡ç®—å™¨
    gregorian_to_lunar: "^N[0-9]{1,8}"      # N å¼€å¤´è§¦å‘å…¬å†è½¬å†œå†
```

**ä½¿ç”¨åœºæ™¯**:
- è¾“å…¥: `U4e2d` â†’ åŒ¹é… `unicode` æ¨¡å¼ â†’ è¾“å‡º "ä¸­"
- è¾“å…¥: `R123` â†’ åŒ¹é… `number` æ¨¡å¼ â†’ è¾“å‡º "å£¹ä½°è´°æ‹¾å"
- è¾“å…¥: `cC1+2` â†’ åŒ¹é… `calculator` æ¨¡å¼ â†’ è¾“å‡º "3"

---

### 3ï¸âƒ£ AbcSegmentor - æ‹¼éŸ³åˆ†æ®µå™¨

**ä½œç”¨**: è¯†åˆ«å¹¶åˆ†å‰²æ‹¼éŸ³è¾“å…¥,è¿™æ˜¯æœ€æ ¸å¿ƒçš„åˆ†æ®µå™¨ã€‚

**æºç ä½ç½®**: `src/rime/gear/abc_segmentor.cc`

**æ ¸å¿ƒé€»è¾‘**:
```cpp
bool AbcSegmentor::Proceed(Segmentation* segmentation) {
  const string& input(segmentation->input());
  size_t j = segmentation->GetCurrentStartPosition();
  size_t k = j;
  bool expecting_an_initial = true;  // æœŸå¾…å£°æ¯
  
  for (; k < input.length(); ++k) {
    // æ£€æŸ¥æ˜¯å¦æ˜¯å­—æ¯è¡¨ä¸­çš„å­—ç¬¦
    bool is_letter = alphabet_.find(input[k]) != string::npos;
    // æ£€æŸ¥æ˜¯å¦æ˜¯åˆ†éš”ç¬¦(å¦‚ç©ºæ ¼ã€å•å¼•å·)
    bool is_delimiter = (k != j) && (delimiter_.find(input[k]) != string::npos);
    
    if (!is_letter && !is_delimiter)
      break;  // é‡åˆ°éæ‹¼éŸ³å­—ç¬¦,åœæ­¢
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯å£°æ¯/éŸµæ¯
    bool is_initial = initials_.find(input[k]) != string::npos;
    bool is_final = finals_.find(input[k]) != string::npos;
    
    // å¦‚æœæœŸå¾…å£°æ¯ä½†é‡åˆ°çš„ä¸æ˜¯å£°æ¯,è¯´æ˜æ‹¼éŸ³æ— æ•ˆ
    if (expecting_an_initial && !is_initial && !is_delimiter) {
      break;
    }
    
    // é‡åˆ°éŸµæ¯æˆ–åˆ†éš”ç¬¦å,ä¸‹ä¸€ä¸ªå­—ç¬¦åº”è¯¥æ˜¯å£°æ¯
    expecting_an_initial = is_final || is_delimiter;
  }
  
  if (j < k) {
    Segment segment(j, k);
    segment.tags.insert("abc");  // æ‰“ä¸Š "abc" æ ‡ç­¾
    segmentation->AddSegment(segment);
  }
  return true;  // ç»§ç»­ä¸‹ä¸€ä¸ª Segmentor
}
```

**é…ç½®ç¤ºä¾‹**:
```yaml
speller:
  alphabet: zyxwvutsrqponmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA`=
  initials: zyxwvutsrqponmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA
  delimiter: " '"  # ç©ºæ ¼å’Œå•å¼•å·ä½œä¸ºåˆ†éš”ç¬¦
```

**ä½¿ç”¨åœºæ™¯**:
- è¾“å…¥: `nihao` â†’ è¯†åˆ«ä¸ºæ‹¼éŸ³ â†’ æ‰“ä¸Š `abc` æ ‡ç­¾
- è¾“å…¥: `ni'hao` â†’ è¯†åˆ«ä¸ºä¸¤ä¸ªæ‹¼éŸ³(ç”¨å•å¼•å·åˆ†éš”) â†’ æ‰“ä¸Š `abc` æ ‡ç­¾
- è¾“å…¥: `ni123` â†’ `ni` æ˜¯æ‹¼éŸ³,`123` ä¸æ˜¯ â†’ åªæœ‰ `ni` æ‰“ä¸Š `abc` æ ‡ç­¾

---

### 4ï¸âƒ£ AffixSegmentor - å‰åç¼€åˆ†æ®µå™¨

**ä½œç”¨**: å¤„ç†å¸¦æœ‰ç‰¹æ®Šå‰ç¼€æˆ–åç¼€çš„è¾“å…¥,å¦‚éƒ¨ä»¶æ‹†å­—åæŸ¥ `uU`ã€‚

**æºç ä½ç½®**: `src/rime/gear/affix_segmentor.cc`

**æ ¸å¿ƒé€»è¾‘**:
```cpp
bool AffixSegmentor::Proceed(Segmentation* segmentation) {
  // æ£€æŸ¥ä¸Šä¸€ä¸ª Segment æ˜¯å¦æœ‰æŒ‡å®šçš„ tag
  if (!segmentation->back().HasTag(tag_)) {
    return true;  // æ²¡æœ‰,ç»§ç»­ä¸‹ä¸€ä¸ª
  }
  
  string active_input(segmentation->input().substr(j, k - j));
  
  // æ£€æŸ¥æ˜¯å¦ä»¥æŒ‡å®šå‰ç¼€å¼€å¤´
  if (!boost::starts_with(active_input, prefix_)) {
    return true;  // ä¸æ˜¯,ç»§ç»­ä¸‹ä¸€ä¸ª
  }
  
  // å°†è¾“å…¥åˆ†ä¸ºä¸‰éƒ¨åˆ†: prefix + code + suffix
  // 1. å‰ç¼€ Segment (æ ‡è®°ä¸º "phony",ä¸ä¸Šå±)
  Segment prefix_segment(j, j + prefix_.length());
  prefix_segment.tags.insert(tag_ + "_prefix");
  prefix_segment.tags.insert("phony");
  segmentation->AddSegment(prefix_segment);
  
  // 2. ä»£ç  Segment (å®é™…è¦æŸ¥è¯¢çš„å†…å®¹)
  Segment code_segment(j + prefix_.length(), k);
  code_segment.tags.insert(tag_);
  segmentation->AddSegment(code_segment);
  
  // 3. åç¼€ Segment (å¦‚æœæœ‰)
  if (boost::ends_with(active_input, suffix_)) {
    Segment suffix_segment(...);
    suffix_segment.tags.insert(tag_ + "_suffix");
    suffix_segment.tags.insert("phony");
    segmentation->AddSegment(suffix_segment);
  }
  
  return false;  // ç‹¬å æ¨¡å¼,åœæ­¢åç»­ Segmentor
}
```

**é…ç½®ç¤ºä¾‹**:
```yaml
radical_lookup:
  tag: radical_lookup
  prefix: "uU"    # å‰ç¼€
  tips: "  ã€”æ‹†å­—ã€•"
```

**ä½¿ç”¨åœºæ™¯**:
- è¾“å…¥: `uUmu` 
  - `uU` â†’ å‰ç¼€ Segment (phony,ä¸ä¸Šå±)
  - `mu` â†’ ä»£ç  Segment (ç”¨äºæŸ¥è¯¢éƒ¨ä»¶æ‹†å­—)
  - ç»“æœ: æ˜¾ç¤º "æœ¨" çš„æ‹†å­—ä¿¡æ¯

---

### 5ï¸âƒ£ PunctSegmentor - æ ‡ç‚¹ç¬¦å·åˆ†æ®µå™¨

**ä½œç”¨**: è¯†åˆ«æ ‡ç‚¹ç¬¦å·è¾“å…¥ã€‚

**æºç ä½ç½®**: `src/rime/gear/punctuator.h` (ç¬¬60-67è¡Œ)

**æ ¸å¿ƒé€»è¾‘**:
```cpp
class PunctSegmentor : public Segmentor {
 public:
  PunctSegmentor(const Ticket& ticket);
  virtual bool Proceed(Segmentation* segmentation);
  
 protected:
  PunctConfig config_;  // æ ‡ç‚¹ç¬¦å·é…ç½®
};
```

**é…ç½®ç¤ºä¾‹**:
```yaml
punctuator:
  half_shape:
    ',' : { commit: ',' }
    '.' : { commit: 'ã€‚' }
    '?' : { commit: '?' }
```

**ä½¿ç”¨åœºæ™¯**:
- è¾“å…¥: `,` â†’ è¯†åˆ«ä¸ºæ ‡ç‚¹ â†’ è¾“å‡º ","
- è¾“å…¥: `.` â†’ è¯†åˆ«ä¸ºæ ‡ç‚¹ â†’ è¾“å‡º "ã€‚"

---

### 6ï¸âƒ£ FallbackSegmentor - å…œåº•åˆ†æ®µå™¨

**ä½œç”¨**: å¤„ç†æ‰€æœ‰å…¶ä»– Segmentor éƒ½æ— æ³•è¯†åˆ«çš„å­—ç¬¦,ä½œä¸ºæœ€åçš„å…œåº•æ–¹æ¡ˆã€‚

**æºç ä½ç½®**: `src/rime/gear/fallback_segmentor.cc`

**æ ¸å¿ƒé€»è¾‘**:
```cpp
bool FallbackSegmentor::Proceed(Segmentation* segmentation) {
  // æ£€æŸ¥å½“å‰æ˜¯å¦è¿˜æœ‰æœªå¤„ç†çš„å­—ç¬¦
  int len = segmentation->GetCurrentSegmentLength();
  if (len > 0)
    return false;  // å·²ç»æœ‰ Segment äº†,ä¸éœ€è¦å…œåº•
  
  const string& input(segmentation->input());
  int k = segmentation->GetCurrentStartPosition();
  if (k == input.length())
    return false;  // å·²ç»åˆ°æœ«å°¾äº†
  
  // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ‰©å±•ä¸Šä¸€ä¸ª raw Segment
  if (!segmentation->empty()) {
    Segment& last(segmentation->back());
    if (last.HasTag("raw")) {
      // æ‰©å±•ä¸Šä¸€ä¸ª raw Segment,åŠ å…¥å½“å‰å­—ç¬¦
      last.end = k + 1;
      last.Clear();
      last.tags.insert("raw");
      return false;
    }
  }
  
  // åˆ›å»ºæ–°çš„ raw Segment,åŒ…å«å½“å‰ä¸€ä¸ªå­—ç¬¦
  Segment segment(k, k + 1);
  segment.tags.insert("raw");
  segmentation->AddSegment(segment);
  
  return false;  // å…œåº• Segmentor åº”è¯¥æ˜¯æœ€åä¸€ä¸ª,åœæ­¢
}
```

**ä½¿ç”¨åœºæ™¯**:
- è¾“å…¥: `niå¥½hao` 
  - `ni` â†’ AbcSegmentor å¤„ç† â†’ `abc` æ ‡ç­¾
  - `å¥½` â†’ å…¶ä»– Segmentor éƒ½ä¸è®¤è¯† â†’ FallbackSegmentor å¤„ç† â†’ `raw` æ ‡ç­¾
  - `hao` â†’ AbcSegmentor å¤„ç† â†’ `abc` æ ‡ç­¾

---

## ğŸ”„ å®Œæ•´çš„åˆ†æ®µæµç¨‹ç¤ºä¾‹

### ç¤ºä¾‹ 1: æ™®é€šæ‹¼éŸ³è¾“å…¥

**è¾“å…¥**: `nihao`

**æ‰§è¡Œæµç¨‹**:
1. **AsciiSegmentor**: æ£€æŸ¥ `ascii_mode` â†’ æœªå¼€å¯ â†’ è¿”å› `true` (ç»§ç»­)
2. **Matcher**: æ£€æŸ¥æ­£åˆ™æ¨¡å¼ â†’ æ— åŒ¹é… â†’ è¿”å› `true` (ç»§ç»­)
3. **AbcSegmentor**: è¯†åˆ« `nihao` ä¸ºæ‹¼éŸ³ â†’ åˆ›å»º Segment[0,5] æ ‡ç­¾:`abc` â†’ è¿”å› `true` (ç»§ç»­)
4. **AffixSegmentor**: æ£€æŸ¥å‰ç¼€ â†’ æ— åŒ¹é… â†’ è¿”å› `true` (ç»§ç»­)
5. **PunctSegmentor**: æ£€æŸ¥æ ‡ç‚¹ â†’ æ— åŒ¹é… â†’ è¿”å› `true` (ç»§ç»­)
6. **FallbackSegmentor**: æ£€æŸ¥æ˜¯å¦æœ‰æœªå¤„ç†å­—ç¬¦ â†’ å·²å…¨éƒ¨å¤„ç† â†’ è¿”å› `false` (ç»“æŸ)

**ç»“æœ**:
```
Segmentation: [
  Segment { start: 0, end: 5, tags: ["abc"] }
]
```

---

### ç¤ºä¾‹ 2: éƒ¨ä»¶æ‹†å­—åæŸ¥

**è¾“å…¥**: `uUmu`

**æ‰§è¡Œæµç¨‹**:
1. **AsciiSegmentor**: æœªå¼€å¯ ASCII æ¨¡å¼ â†’ è¿”å› `true`
2. **Matcher**: åŒ¹é… `radical_lookup` æ¨¡å¼ â†’ åˆ›å»º Segment[0,4] æ ‡ç­¾:`radical_lookup` â†’ è¿”å› `true`
3. **AbcSegmentor**: æ£€æŸ¥ Segment â†’ å·²æœ‰ `radical_lookup` æ ‡ç­¾ â†’ è¿”å› `true`
4. **AffixSegmentor**: 
   - æ£€æµ‹åˆ°å‰ç¼€ `uU`
   - åˆ†å‰²ä¸º: `uU`(å‰ç¼€) + `mu`(ä»£ç )
   - åˆ›å»ºä¸¤ä¸ª Segment:
     - Segment[0,2] æ ‡ç­¾:`radical_lookup_prefix`, `phony`
     - Segment[2,4] æ ‡ç­¾:`radical_lookup`
   - è¿”å› `false` (ç‹¬å ,åœæ­¢)

**ç»“æœ**:
```
Segmentation: [
  Segment { start: 0, end: 2, tags: ["radical_lookup_prefix", "phony"] },
  Segment { start: 2, end: 4, tags: ["radical_lookup"] }
]
```

---

### ç¤ºä¾‹ 3: æ··åˆè¾“å…¥

**è¾“å…¥**: `niå¥½hao`

**æ‰§è¡Œæµç¨‹**:

**ç¬¬ä¸€è½®** (å¤„ç† `ni`):
1. AbcSegmentor: è¯†åˆ« `ni` â†’ Segment[0,2] æ ‡ç­¾:`abc`

**ç¬¬äºŒè½®** (å¤„ç† `å¥½`):
1. AsciiSegmentor: æœªå¼€å¯ â†’ ç»§ç»­
2. Matcher: æ— åŒ¹é… â†’ ç»§ç»­
3. AbcSegmentor: `å¥½` ä¸æ˜¯æ‹¼éŸ³å­—æ¯ â†’ æ— æ³•å¤„ç† â†’ ç»§ç»­
4. AffixSegmentor: æ— å‰ç¼€ â†’ ç»§ç»­
5. PunctSegmentor: ä¸æ˜¯æ ‡ç‚¹ â†’ ç»§ç»­
6. FallbackSegmentor: æ— æ³•è¯†åˆ« â†’ åˆ›å»º Segment[2,3] æ ‡ç­¾:`raw`

**ç¬¬ä¸‰è½®** (å¤„ç† `hao`):
1. AbcSegmentor: è¯†åˆ« `hao` â†’ Segment[3,6] æ ‡ç­¾:`abc`

**ç»“æœ**:
```
Segmentation: [
  Segment { start: 0, end: 2, tags: ["abc"] },      // "ni"
  Segment { start: 2, end: 3, tags: ["raw"] },      // "å¥½"
  Segment { start: 3, end: 6, tags: ["abc"] }       // "hao"
]
```

---

## ğŸ¯ Segment å’Œ Tag çš„ä½œç”¨

### Segment ç»“æ„

```cpp
struct Segment {
  enum Status { kVoid, kGuess, kSelected, kConfirmed };
  
  Status status;           // çŠ¶æ€
  size_t start;            // èµ·å§‹ä½ç½®
  size_t end;              // ç»“æŸä½ç½®
  size_t length;           // é•¿åº¦
  set<string> tags;        // æ ‡ç­¾é›†åˆ â­
  an<Menu> menu;           // å€™é€‰èœå•
  size_t selected_index;   // é€‰ä¸­çš„å€™é€‰é¡¹ç´¢å¼•
  string prompt;           // æç¤ºä¿¡æ¯
};
```

### å¸¸è§ Tag åŠå…¶å«ä¹‰

| Tag | å«ä¹‰ | ç”±å“ªä¸ª Segmentor æ·»åŠ  | ç”±å“ªä¸ª Translator å¤„ç† |
|-----|------|----------------------|---------------------|
| `raw` | åŸå§‹å­—ç¬¦,ç›´æ¥è¾“å‡º | AsciiSegmentor, FallbackSegmentor | - |
| `abc` | æ‹¼éŸ³è¾“å…¥ | AbcSegmentor | ScriptTranslator |
| `punct` | æ ‡ç‚¹ç¬¦å· | Matcher (é€šè¿‡ recognizer) | PunctTranslator |
| `radical_lookup` | éƒ¨ä»¶æ‹†å­—åæŸ¥ | Matcher, AffixSegmentor | TableTranslator@radical_lookup |
| `unicode` | Unicode è¾“å…¥ | Matcher | lua_translator@*unicode |
| `number` | æ•°å­—å¤§å†™ | Matcher | lua_translator@*number_translator |
| `calculator` | è®¡ç®—å™¨ | Matcher | lua_translator@*calc_translator |
| `phony` | è™šæ‹Ÿ Segment,ä¸ä¸Šå± | AffixSegmentor | - |

---

## ğŸ› ï¸ å¦‚ä½•è‡ªå®šä¹‰ Segmentor

### æ­¥éª¤ 1: åˆ›å»ºå¤´æ–‡ä»¶

```cpp
// src/rime/gear/my_segmentor.h
#ifndef RIME_MY_SEGMENTOR_H_
#define RIME_MY_SEGMENTOR_H_

#include <rime/segmentor.h>

namespace rime {

class MySegmentor : public Segmentor {
 public:
  explicit MySegmentor(const Ticket& ticket);
  virtual bool Proceed(Segmentation* segmentation);
  
 protected:
  string my_config_;  // è‡ªå®šä¹‰é…ç½®
};

}  // namespace rime

#endif  // RIME_MY_SEGMENTOR_H_
```

### æ­¥éª¤ 2: å®ç° Proceed æ–¹æ³•

```cpp
// src/rime/gear/my_segmentor.cc
#include <rime/gear/my_segmentor.h>

namespace rime {

MySegmentor::MySegmentor(const Ticket& ticket) : Segmentor(ticket) {
  // ä»é…ç½®æ–‡ä»¶è¯»å–è®¾ç½®
  if (ticket.schema && ticket.schema->config()) {
    ticket.schema->config()->GetString("my_segmentor/config", &my_config_);
  }
}

bool MySegmentor::Proceed(Segmentation* segmentation) {
  // è·å–å½“å‰è¾“å…¥
  const string& input = segmentation->input();
  size_t start = segmentation->GetCurrentStartPosition();
  
  // å®ç°ä½ çš„åˆ†æ®µé€»è¾‘
  // ä¾‹å¦‚: æ£€æµ‹ç‰¹æ®Šæ¨¡å¼
  if (input.substr(start, 2) == "@@") {
    // åˆ›å»º Segment
    Segment segment(start, start + 2);
    segment.tags.insert("my_tag");
    segmentation->AddSegment(segment);
    return false;  // ç‹¬å æ¨¡å¼
  }
  
  return true;  // ç»§ç»­ä¸‹ä¸€ä¸ª Segmentor
}

}  // namespace rime
```

### æ­¥éª¤ 3: æ³¨å†Œç»„ä»¶

```cpp
// src/rime/gear/gears_module.cc
#include <rime/gear/my_segmentor.h>

void RegisterComponents(Registry* registry) {
  // ... å…¶ä»–ç»„ä»¶ ...
  registry->Register("my_segmentor", new Component<MySegmentor>);
}
```

### æ­¥éª¤ 4: åœ¨é…ç½®æ–‡ä»¶ä¸­ä½¿ç”¨

```yaml
# my_schema.schema.yaml
engine:
  segmentors:
    - ascii_segmentor
    - matcher
    - my_segmentor      # æ·»åŠ ä½ çš„ Segmentor
    - abc_segmentor
    - punct_segmentor
    - fallback_segmentor

my_segmentor:
  config: "some_value"
```

---

## ğŸ’¡ æœ€ä½³å®è·µ

### 1. Segmentor çš„é¡ºåºå¾ˆé‡è¦

- **ä¸“ç”¨ Segmentor æ”¾å‰é¢**: å¦‚ `ascii_segmentor`, `matcher`
- **é€šç”¨ Segmentor æ”¾ä¸­é—´**: å¦‚ `abc_segmentor`, `affix_segmentor`
- **å…œåº• Segmentor æ”¾æœ€å**: `fallback_segmentor` å¿…é¡»æœ€å

### 2. è¿”å›å€¼çš„é€‰æ‹©

- è¿”å› `true`: è®©å…¶ä»– Segmentor ç»§ç»­å¤„ç†(åä½œæ¨¡å¼)
- è¿”å› `false`: ç‹¬å å½“å‰è¾“å…¥,åœæ­¢åç»­å¤„ç†(ç‹¬å æ¨¡å¼)

### 3. Tag çš„å‘½åè§„èŒƒ

- ä½¿ç”¨å°å†™å­—æ¯å’Œä¸‹åˆ’çº¿
- è¯­ä¹‰æ¸…æ™°,å¦‚ `abc`, `raw`, `punct`
- ç‰¹æ®Šç”¨é€”çš„ Tag: `phony`(ä¸ä¸Šå±), `partial`(éƒ¨åˆ†é€‰æ‹©)

### 4. æ€§èƒ½ä¼˜åŒ–

- å°½æ—©è¿”å›: ä¸åŒ¹é…çš„æƒ…å†µä¸‹å°½å¿«è¿”å› `true`
- é¿å…é‡å¤è®¡ç®—: ç¼“å­˜é…ç½®å’Œæ­£åˆ™è¡¨è¾¾å¼
- å‡å°‘å­—ç¬¦ä¸²æ“ä½œ: ä½¿ç”¨ `string_view` æˆ–ç´¢å¼•

---

## ğŸ” è°ƒè¯•æŠ€å·§

### 1. å¯ç”¨æ—¥å¿—

åœ¨æºç ä¸­ä½¿ç”¨ `DLOG(INFO)`:

```cpp
bool MySegmentor::Proceed(Segmentation* segmentation) {
  DLOG(INFO) << "my_segmentor: input=" << segmentation->input();
  DLOG(INFO) << "current start pos: " << segmentation->GetCurrentStartPosition();
  // ...
}
```

### 2. æŸ¥çœ‹ Segmentation çŠ¶æ€

```cpp
DLOG(INFO) << "segmentation: " << *segmentation;
```

è¾“å‡ºç¤ºä¾‹:
```
segmentation: [Segment(0,2,abc), Segment(2,3,raw), Segment(3,6,abc)]
```

### 3. ä½¿ç”¨ RIME è°ƒè¯•å·¥å…·

```bash
# ç¼–è¯‘ debug ç‰ˆæœ¬
cmake -B build -DCMAKE_BUILD_TYPE=Debug
make -C build

# è¿è¡Œæµ‹è¯•
./build/bin/rime_api_console
```

---

## ğŸ“– ç›¸å…³æºç æ–‡ä»¶

| æ–‡ä»¶ | è¯´æ˜ |
|------|------|
| `src/rime/segmentor.h` | Segmentor åŸºç±»å®šä¹‰ |
| `src/rime/segmentation.h` | Segment å’Œ Segmentation ç±»å®šä¹‰ |
| `src/rime/gear/ascii_segmentor.{h,cc}` | ASCII æ¨¡å¼åˆ†æ®µå™¨ |
| `src/rime/gear/matcher.{h,cc}` | æ¨¡å¼åŒ¹é…åˆ†æ®µå™¨ |
| `src/rime/gear/abc_segmentor.{h,cc}` | æ‹¼éŸ³åˆ†æ®µå™¨ |
| `src/rime/gear/affix_segmentor.{h,cc}` | å‰åç¼€åˆ†æ®µå™¨ |
| `src/rime/gear/punctuator.{h,cc}` | æ ‡ç‚¹ç¬¦å·åˆ†æ®µå™¨ |
| `src/rime/gear/fallback_segmentor.{h,cc}` | å…œåº•åˆ†æ®µå™¨ |
| `src/rime/gear/recognizer.{h,cc}` | æ­£åˆ™æ¨¡å¼è¯†åˆ«å™¨ |

---

## ğŸ“ æ€»ç»“

### Segmentor çš„æ ¸å¿ƒèŒè´£

1. **è¾“å…¥åˆ†ç±»**: å°†è¾“å…¥å­—ç¬¦ä¸²åˆ‡åˆ†æˆä¸åŒç±»å‹çš„æ®µè½
2. **æ‰“æ ‡ç­¾**: ä¸ºæ¯ä¸ªæ®µè½æ‰“ä¸Šç›¸åº”çš„æ ‡ç­¾
3. **æµç¨‹æ§åˆ¶**: å†³å®šæ˜¯å¦ç»§ç»­æ‰§è¡Œåç»­ Segmentor

### å…­å¤§ Segmentor çš„åˆ†å·¥

1. **AsciiSegmentor**: å¤„ç† ASCII æ¨¡å¼
2. **Matcher**: å¤„ç†ç‰¹æ®Šæ¨¡å¼(æ­£åˆ™åŒ¹é…)
3. **AbcSegmentor**: å¤„ç†æ‹¼éŸ³è¾“å…¥
4. **AffixSegmentor**: å¤„ç†å¸¦å‰åç¼€çš„è¾“å…¥
5. **PunctSegmentor**: å¤„ç†æ ‡ç‚¹ç¬¦å·
6. **FallbackSegmentor**: å…œåº•å¤„ç†æ— æ³•è¯†åˆ«çš„å­—ç¬¦

### å…³é”®æ¦‚å¿µ

- **Segment**: è¾“å…¥çš„ä¸€ä¸ªç‰‡æ®µ,åŒ…å«èµ·æ­¢ä½ç½®ã€æ ‡ç­¾ã€å€™é€‰èœå•ç­‰
- **Tag**: æ ‡è¯† Segment ç±»å‹çš„æ ‡ç­¾,å†³å®šç”±å“ªä¸ª Translator å¤„ç†
- **Proceed**: Segmentor çš„æ ¸å¿ƒæ–¹æ³•,è¿”å› `true` ç»§ç»­,è¿”å› `false` åœæ­¢

---

## ğŸ“š å»¶ä¼¸é˜…è¯»

- [Translator å­¦ä¹ æŒ‡å—](./TRANSLATORS_LEARNING_GUIDE.md) (ä¸‹ä¸€æ­¥å­¦ä¹ )
- [Filter å­¦ä¹ æŒ‡å—](./FILTERS_LEARNING_GUIDE.md)
- [RIME å®˜æ–¹æ–‡æ¡£](https://github.com/rime/home/wiki)

---

**æ–‡æ¡£åˆ›å»ºæ—¶é—´**: 2025-01-26  
**é€‚ç”¨ librime ç‰ˆæœ¬**: 1.14.0+  
**ä½œè€…**: Cascade AI Assistant
