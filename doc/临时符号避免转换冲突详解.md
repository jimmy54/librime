# 临时符号避免转换冲突详解

## 问题背景

在双拼方案中，我们需要将全拼音节转换为双拼按键。如果直接使用最终的按键字母进行转换，会导致**转换冲突**。

---

## 冲突示例 1：声母转换冲突

### 错误方案（不使用临时符号）

```yaml
speller:
  algebra:
    - xform/^zh/v/   # 将 zh 转换为 v
    - xform/^sh/u/   # 将 sh 转换为 u
    - xform/^ch/i/   # 将 ch 转换为 i
    - xform/uo$/o/   # 将韵母 uo 转换为 o
```

### 问题分析

#### 音节 "zhu" 的转换过程

```
原音节: zhu
  ↓ 规则1: xform/^zh/v/
中间态: vu
  ↓ 规则4: xform/uo$/o/  ← 问题！
结果: vu (没有匹配到 uo，因为是 u 不是 uo)
```

看起来没问题？**但是**：

#### 音节 "zhuo" 的转换过程

```
原音节: zhuo
  ↓ 规则1: xform/^zh/v/
中间态: vuo
  ↓ 规则4: xform/uo$/o/
结果: vo  ✓ 正确
```

#### 音节 "shuo" 的转换过程

```
原音节: shuo
  ↓ 规则2: xform/^sh/u/
中间态: uuo  ← 问题！
  ↓ 规则4: xform/uo$/o/
结果: uo
```

**冲突发生**：`sh` 被转换为 `u`，导致 `shuo` 变成 `uuo`，而不是期望的 `uo`！

---

## 冲突示例 2：韵母被误匹配

### 错误方案

```yaml
speller:
  algebra:
    - xform/^zh/v/
    - xform/ang$/s/   # 将 ang 转换为 s
    - xform/an$/f/    # 将 an 转换为 f
```

### 问题分析

#### 音节 "zhang" 的转换过程

```
原音节: zhang
  ↓ 规则1: xform/^zh/v/
中间态: vang
  ↓ 规则2: xform/ang$/s/
结果: vs  ✓ 正确
```

#### 音节 "zhan" 的转换过程

```
原音节: zhan
  ↓ 规则1: xform/^zh/v/
中间态: van
  ↓ 规则2: xform/ang$/s/  ← 不匹配
  ↓ 规则3: xform/an$/f/
结果: vf  ✓ 正确
```

看起来没问题？**但是如果规则顺序错误**：

```yaml
speller:
  algebra:
    - xform/^zh/v/
    - xform/an$/f/    # 先处理 an
    - xform/ang$/s/   # 后处理 ang
```

#### 音节 "zhang" 的转换过程（错误顺序）

```
原音节: zhang
  ↓ 规则1: xform/^zh/v/
中间态: vang
  ↓ 规则2: xform/an$/f/  ← 匹配到了！
结果: vfg  ✗ 错误！
```

**冲突发生**：`ang` 中的 `an` 被误匹配，导致 `zhang` 变成 `vfg` 而不是 `vs`！

---

## 冲突示例 3：多次转换导致的混乱

### 错误方案

```yaml
speller:
  algebra:
    - xform/^zh/v/
    - xform/^ch/i/
    - xform/ing$/g/
    - xform/in$/b/
    - xform/i$/i/    # 保持单独的 i
```

### 问题分析

#### 音节 "ching" (方言音节)

```
原音节: ching
  ↓ 规则2: xform/^ch/i/
中间态: iing  ← 问题！
  ↓ 规则3: xform/ing$/g/
结果: ig
```

**冲突发生**：`ch` 被转换为 `i`，导致 `ching` 变成 `iing`，而 `iing` 看起来像是 `i + ing`！

#### 音节 "vin" (如果存在)

```
原音节: vin
  ↓ 规则4: xform/in$/b/
结果: vb
```

但是如果有音节 `vi`：

```
原音节: vi
  ↓ 规则5: xform/i$/i/
结果: vi
```

如果后续还有规则 `xform/vi/某个键/`，就会与 `vin` 转换后的 `vb` 混淆！

---

## 正确方案：使用临时符号

### 完整规则

```yaml
speller:
  algebra:
    # 第一步：使用临时符号转换声母
    - xform/^sh/Ⓤ/
    - xform/^ch/Ⓘ/
    - xform/^zh/Ⓥ/
    
    # 第二步：使用临时符号转换韵母
    - xform/uo$/Ⓞ/
    - xform/[iu]ang$/Ⓓ/
    - xform/ang$/Ⓢ/
    - xform/ing$/Ⓖ/
    - xform/in$/Ⓑ/
    
    # 第三步：批量转换临时符号为最终按键
    - xlit/ⓊⒾⓋⓄⒹⓈⒼⒷ/uivodsgb/
```

### 优势分析

#### 音节 "shuo" 的转换过程

```
原音节: shuo
  ↓ 规则1: xform/^sh/Ⓤ/
中间态: Ⓤuo
  ↓ 规则4: xform/uo$/Ⓞ/
中间态: ⓊⓄ
  ↓ 规则11: xlit/ⓊⓄ.../uo.../
最终: uo  ✓ 正确！
```

**没有冲突**：因为 `Ⓤ` 不会与任何韵母字母冲突！

#### 音节 "zhang" 的转换过程

```
原音节: zhang
  ↓ 规则3: xform/^zh/Ⓥ/
中间态: Ⓥang
  ↓ 规则6: xform/ang$/Ⓢ/
中间态: ⓋⓈ
  ↓ 规则11: xlit/ⓋⓈ.../vs.../
最终: vs  ✓ 正确！
```

#### 音节 "zhan" 的转换过程

```
原音节: zhan
  ↓ 规则3: xform/^zh/Ⓥ/
中间态: Ⓥan
  ↓ 规则6: xform/ang$/Ⓢ/  ← 不匹配（因为是 an 不是 ang）
  ↓ 其他韵母规则...
中间态: Ⓥan (假设没有 an 规则)
  ↓ 规则11: xlit/Ⓥ.../v.../
最终: van  ✓ 正确！
```

**关键点**：即使规则顺序错误，也不会误匹配，因为：
- `Ⓥang` 中的 `Ⓥan` 不会匹配 `xform/an$/f/`（因为 `Ⓥ` 不是拼音字母）
- 只有完整的 `ang` 才会被匹配

---

## 冲突示例 4：韵母内部冲突

### 错误方案

```yaml
speller:
  algebra:
    - xform/iang$/d/
    - xform/uang$/d/
    - xform/ang$/s/
    - xform/an$/f/
    - xform/ian$/m/
```

### 问题分析

#### 音节 "xiang" 的转换过程

```
原音节: xiang
  ↓ 规则1: xform/iang$/d/
结果: xd  ✓ 正确
```

#### 音节 "xian" 的转换过程

```
原音节: xian
  ↓ 规则1: xform/iang$/d/  ← 不匹配
  ↓ 规则5: xform/ian$/m/
结果: xm  ✓ 正确
```

看起来没问题？**但是如果规则顺序错误**：

```yaml
speller:
  algebra:
    - xform/an$/f/    # 先处理 an
    - xform/ang$/s/
    - xform/ian$/m/
    - xform/iang$/d/
```

#### 音节 "xiang" 的转换过程（错误顺序）

```
原音节: xiang
  ↓ 规则1: xform/an$/f/  ← 匹配到了！
中间态: xiafg  ✗ 错误！
```

**冲突发生**：`iang` 中的 `an` 被误匹配！

### 正确方案（使用临时符号）

```yaml
speller:
  algebra:
    - xform/[iu]ang$/Ⓓ/   # iang 和 uang 都转换为 Ⓓ
    - xform/ang$/Ⓢ/
    - xform/[iu]an$/Ⓜ/    # ian 和 uan 都转换为 Ⓜ
    - xform/an$/Ⓕ/
    - xlit/ⒹⓈⓂⒻ/dsmf/
```

#### 音节 "xiang" 的转换过程

```
原音节: xiang
  ↓ 规则1: xform/[iu]ang$/Ⓓ/
中间态: xⓓ
  ↓ 规则2: xform/ang$/Ⓢ/  ← 不匹配（因为 Ⓓ 不是 ang）
  ↓ 规则5: xlit/Ⓓ.../d.../
最终: xd  ✓ 正确！
```

**无论规则顺序如何，都不会冲突**！

---

## 冲突示例 5：声母和韵母的交叉冲突

### 错误方案

```yaml
speller:
  algebra:
    - xform/^zh/v/
    - xform/^sh/u/
    - xform/^v/v/     # 保留声母 v (ü)
    - xform/ve$/ve/   # 保留韵母 ve (üe)
```

### 问题分析

#### 音节 "zhe" 的转换过程

```
原音节: zhe
  ↓ 规则1: xform/^zh/v/
中间态: ve
  ↓ 规则4: xform/ve$/ve/  ← 误匹配！
结果: ve
```

**冲突发生**：`zhe` 被转换为 `ve`，但 `ve` 应该是韵母 `üe` 的编码，而不是 `zh + e`！

#### 音节 "lve" (lüe) 的转换过程

```
原音节: lve
  ↓ 规则4: xform/ve$/ve/
结果: lve  ✓ 正确
```

但是现在 `zhe` 和 `lve` 都包含 `ve`，无法区分！

### 正确方案（使用临时符号）

```yaml
speller:
  algebra:
    - xform/^zh/Ⓥ/
    - xform/^sh/Ⓤ/
    - xform/^v/V/     # 使用大写 V 作为临时符号
    - xform/Ve$/Ⓥⓔ/   # ve (üe) 转换为临时符号
    - xform/e$/E/     # 其他 e 转换为大写 E
    - xlit/ⓋⓊⓋⒺVE/VUVEve/
```

#### 音节 "zhe" 的转换过程

```
原音节: zhe
  ↓ 规则1: xform/^zh/Ⓥ/
中间态: Ⓥe
  ↓ 规则5: xform/e$/E/
中间态: ⓋE
  ↓ 规则6: xlit/ⓋE.../ve.../
最终: ve  ✓ 正确
```

#### 音节 "lve" (lüe) 的转换过程

```
原音节: lve
  ↓ 规则3: xform/^v/V/
中间态: lVe
  ↓ 规则4: xform/Ve$/Ⓥⓔ/
中间态: lⓋⓔ
  ↓ 规则6: xlit/Ⓥⓔ.../VE.../
最终: lVE  ✓ 不同于 zhe 的 ve！
```

---

## 临时符号的选择原则

### 1. 不与拼音字母冲突

```
✓ 使用: Ⓤ Ⓘ Ⓥ Ⓞ Ⓓ Ⓢ Ⓖ Ⓑ Ⓝ Ⓜ (带圈字母)
✓ 使用: Ü Ï Ö (带音标的字母)
✗ 避免: U I V O D S G B N M (普通字母)
```

### 2. 不与声调数字冲突

```
✓ 使用: Ⓤ Ⓘ (不是数字)
✗ 避免: 1 2 3 4 5 (会与声调混淆)
```

### 3. 易于区分

```
✓ 使用: Ⓤ (带圈U) vs U (普通U)
✗ 避免: u (小写) vs U (大写) - 容易混淆
```

### 4. UTF-8 编码安全

```
✓ 使用: Ⓤ (U+24CA) - 单个 Unicode 字符
✗ 避免: 组合字符 - 可能导致编码问题
```

---

## 代码层面的体现

### Transformation::Apply（正则替换）

```cpp
bool Transformation::Apply(Spelling* spelling) {
  // 输入: spelling->str = "zhang"
  // pattern_ = "^zh", replacement_ = "Ⓥ"
  
  string result = boost::regex_replace(spelling->str, pattern_, replacement_);
  // result = "Ⓥang"
  
  // 关键：Ⓥ 不会与后续的 ang 规则冲突
  // 因为 Ⓥ 不是拼音字母，不会被误匹配
  
  spelling->str.swap(result);
  return true;
}
```

### Transliteration::Apply（字符映射）

```cpp
bool Transliteration::Apply(Spelling* spelling) {
  // 输入: spelling->str = "ⓋⓈ"
  
  // char_map_ = {'Ⓥ': 'v', 'Ⓢ': 's'}
  
  const char* p = spelling->str.c_str();
  char buffer[256] = "";
  char* q = buffer;
  uint32_t c;
  
  while ((c = utf8::unchecked::next(p))) {
    if (char_map_.find(c) != char_map_.end()) {
      c = char_map_[c];  // Ⓥ -> v, Ⓢ -> s
    }
    q = utf8::unchecked::append(c, q);
  }
  
  // buffer = "vs"
  spelling->str.assign(buffer);
  return true;
}
```

---

## 总结

### 为什么需要临时符号？

1. **避免声母转换冲突**：`sh` → `u` 会与韵母 `u` 冲突
2. **避免韵母误匹配**：`ang` 中的 `an` 可能被误匹配
3. **避免多次转换混乱**：中间态使用拼音字母会导致后续规则误匹配
4. **避免声母韵母交叉冲突**：`zh` → `v` 会与声母 `v` (ü) 冲突
5. **规则顺序无关**：使用临时符号后，规则顺序不影响结果

### 临时符号的本质

临时符号是**中间态的命名空间隔离**：
- 拼音字母空间：`a-z`（用于原始音节和最终按键）
- 临时符号空间：`Ⓤ Ⓘ Ⓥ ...`（用于中间转换）
- 两个空间互不干扰，避免冲突

### 类比

就像编程中的**临时变量**：

```cpp
// 错误：直接交换会覆盖
a = b;  // a 的原值丢失
b = a;  // b 变成了 b，没有交换

// 正确：使用临时变量
temp = a;  // 临时保存 a
a = b;
b = temp;  // 完成交换
```

临时符号就是拼写转换中的 `temp` 变量！
