# 为什么"庭"没有排到第一位？问题分析

## 🎯 问题描述

**输入记录**：
```
1. 输入 "jia" → 选择 "家"
2. 上下文设置为 "家"
3. 输入 "ting"
4. 候选列表：
   1. [听]  ← 排第一
   2.  庭   ← 期望排第一（家庭）
   3.  挺
   4.  停
   5.  厅
   6.  廷
```

**问题**：为什么"庭"没有排到第一位？明明"家庭"是常见搭配！

---

## 🔍 问题根源分析

### 根源1：配置文件中 contextual_suggestions 设置不一致

检查你的配置文件：

#### wanxiang.schema.yaml（主配置）
```yaml
# Line 1214
translator/contextual_suggestions: true  # ✅ 已启用
```

#### user_profile/sync/.../wanxiang.schema.yaml（用户配置）
```yaml
# Line 1214
translator/contextual_suggestions: false  # ❌ 被禁用了！
```

**关键发现**：
- ✅ 主配置文件启用了上下文建议
- ❌ 但用户配置文件（同步目录）中被禁用了
- ❌ **用户配置会覆盖主配置**

---

### 根源2：ContextualWeighted 未生效

由于 `contextual_suggestions: false`，代码执行路径如下：

```cpp
// script_translator.cc L219-222
auto deduped = New<DistinctTranslation>(result);
if (contextual_suggestions_) {  // ← false，不执行
  return poet_->ContextualWeighted(deduped, input, segment.start, this);
}
return deduped;  // ← 直接返回，没有上下文评分
```

**结果**：
- ❌ 没有调用 `ContextualWeighted`
- ❌ 没有使用 Octagram 评分
- ❌ 候选按 **词典权重** 排序（不考虑上下文）

---

## 📊 实际执行流程

### 当前执行流程（contextual_suggestions: false）

```
输入 "ting"
    ↓
ScriptTranslator::Query()
    ↓
ScriptTranslation::Evaluate()
    ├─ 构建音节图
    ├─ 查询词典
    │   ├─ 听: 词典权重 -3.5
    │   ├─ 庭: 词典权重 -5.2
    │   ├─ 挺: 词典权重 -5.8
    │   └─ ...
    └─ 不造句（只有1个音节）
    ↓
去重: DistinctTranslation
    ↓
判断: contextual_suggestions_ = false ❌
    ↓
直接返回（不使用上下文评分）
    ↓
候选列表（按词典权重排序）:
1. 听 (-3.5)  ← 词频最高
2. 庭 (-5.2)
3. 挺 (-5.8)
```

---

### 期望执行流程（contextual_suggestions: true）

```
输入 "ting"
上下文: "家"
    ↓
ScriptTranslator::Query()
    ↓
ScriptTranslation::Evaluate()
    ├─ 构建音节图
    ├─ 查询词典
    │   ├─ 听: 词典权重 -3.5
    │   ├─ 庭: 词典权重 -5.2
    │   ├─ 挺: 词典权重 -5.8
    │   └─ ...
    └─ 不造句（只有1个音节）
    ↓
去重: DistinctTranslation
    ↓
判断: contextual_suggestions_ = true ✅
    ↓
⭐ 调用 poet_->ContextualWeighted()
    ↓
ContextualTranslation::Replenish()
    ├─ 收集候选（最多32个）
    ├─ 对每个候选评分:
    │   ├─ 听: -3.5 + Octagram("家", "听") = -3.5 + (-12.0) = -15.5
    │   ├─ 庭: -5.2 + Octagram("家", "庭") = -5.2 + (-2.0) = -7.2  ← 最优
    │   ├─ 挺: -5.8 + Octagram("家", "挺") = -5.8 + (-12.0) = -17.8
    │   └─ ...
    └─ 排序（按权重降序）
    ↓
候选列表（按上下文评分排序）:
1. 庭 (-7.2)  ← 上下文最优 ✅
2. 听 (-15.5)
3. 挺 (-17.8)
```

---

## 🔑 关键差异对比

### 不使用上下文评分（当前）

| 候选 | 词典权重 | 上下文评分 | 最终权重 | 排名 |
|------|---------|-----------|---------|------|
| 听 | -3.5 | - | -3.5 | 1 ❌ |
| 庭 | -5.2 | - | -5.2 | 2 |
| 挺 | -5.8 | - | -5.8 | 3 |

**问题**：只看词频，"听"最常用，所以排第一。

---

### 使用上下文评分（期望）

| 候选 | 词典权重 | 上下文评分 | 最终权重 | 排名 |
|------|---------|-----------|---------|------|
| 听 | -3.5 | -12.0 | -15.5 | 2 |
| 庭 | -5.2 | -2.0 | -7.2 | 1 ✅ |
| 挺 | -5.8 | -12.0 | -17.8 | 3 |

**解释**：
- "家庭" 是常见搭配，Octagram 给出 **-2.0**（高分）
- "家听" 不是常见搭配，Octagram 给出 **-12.0**（低分）
- 最终 "庭" 的总分最高，排第一 ✅

---

## 💡 Octagram 评分机制

### 评分公式

```cpp
// contextual_translation.cc L41-48
an<Phrase> ContextualTranslation::Evaluate(an<Phrase> phrase) {
  bool is_rear = phrase->end() == input_.length();
  
  // 最终权重 = 词典权重 + 上下文评分
  double weight = Grammar::Evaluate(preceding_text_, phrase->text(),
                                    phrase->weight(), is_rear, grammar_);
  
  phrase->set_weight(weight);
  return phrase;
}
```

### Grammar::Evaluate 内部

```cpp
// grammar.h L18-26
inline static double Evaluate(const string& context,
                              const string& entry_text,
                              double entry_weight,      // 词典权重
                              bool is_rear,
                              Grammar* grammar) {
  const double kPenalty = -18.420680743952367;  // log(1e-8)
  
  // 最终权重 = 词典权重 + 上下文评分
  return entry_weight +
         (grammar ? grammar->Query(context, entry_text, is_rear) : kPenalty);
}
```

### Octagram::Query 评分规则

```cpp
// octagram.cc L106-163
double Octagram::Query(const string& context,
                       const string& word,
                       bool is_rear) {
  if (!db_ || context.empty()) {
    return config_->non_collocation_penalty;  // -12
  }
  
  double result = config_->non_collocation_penalty;  // 默认 -12
  
  // 在语法数据库中查询搭配
  int num_results = db_->Lookup(context_ptr, word_query, matches);
  
  for (auto i = 0; i < num_results; ++i) {
    const auto& match(matches[i]);
    const int collocation_len = context_len + match_len;
    
    // 更新评分
    if (collocation_len >= config_->collocation_min_length) {
      result = scale_value(match.value) + 
               config_->collocation_penalty;      // -12（强搭配）
    } else {
      result = scale_value(match.value) + 
               config_->weak_collocation_penalty; // -24（弱搭配）
    }
  }
  
  return result;  // 返回 -12 到 0 之间的值
}
```

**评分范围**：
- **强搭配**（如"家庭"）：-2.0 到 0（高分）
- **弱搭配**：-12.0 到 -24.0（中等）
- **无搭配**（如"家听"）：-12.0（低分，默认惩罚）

---

## 🎨 实际案例演示

### 案例：输入 "ting"，上下文 "家"

#### 候选1：听
```
词典权重: -3.5 (词频高)
上下文评分: Octagram("家", "听")
  └─ 数据库中没有 "家听" 搭配
  └─ 返回默认惩罚: -12.0
最终权重: -3.5 + (-12.0) = -15.5
```

#### 候选2：庭
```
词典权重: -5.2 (词频中等)
上下文评分: Octagram("家", "庭")
  └─ 数据库中有 "家庭" 搭配 ✅
  └─ 返回强搭配评分: -2.0
最终权重: -5.2 + (-2.0) = -7.2  ← 最优
```

#### 候选3：挺
```
词典权重: -5.8 (词频中等)
上下文评分: Octagram("家", "挺")
  └─ 数据库中没有 "家挺" 搭配
  └─ 返回默认惩罚: -12.0
最终权重: -5.8 + (-12.0) = -17.8
```

**排序结果**：
1. 庭 (-7.2)  ← 上下文最优 ✅
2. 听 (-15.5)
3. 挺 (-17.8)

---

## 🛠️ 解决方案

### 方案1：修改用户配置文件（推荐）

编辑文件：
```
/Users/jimmy54/Pictures/jimmy_librime/librime/cmake-build-debug/bin/user_profile/sync/.../wanxiang.schema.yaml
```

修改第 1214 行：
```yaml
# 修改前
translator/contextual_suggestions: false

# 修改后
translator/contextual_suggestions: true  # ✅ 启用上下文建议
```

---

### 方案2：使用 custom.yaml 覆盖

创建或编辑：
```
/Users/jimmy54/Pictures/jimmy_librime/librime/cmake-build-debug/bin/custom/wanxiang.custom.yaml
```

添加：
```yaml
patch:
  translator/contextual_suggestions: true  # 强制启用
```

---

### 方案3：删除用户配置，重新部署

```bash
cd /Users/jimmy54/Pictures/jimmy_librime/librime/cmake-build-debug/bin

# 删除用户配置
rm -rf user_profile/sync/*/wanxiang.schema.yaml

# 重新部署
./rime_deployer --build user_profile
```

---

## 🔍 验证方法

### 方法1：检查配置是否生效

重新部署后，查看日志：
```bash
./rime_console

# 输入 "jia" 选择 "家"
# 输入 "ting"
# 查看候选列表
```

如果 `contextual_suggestions: true` 生效，你应该看到：
```
1. [庭]  ← 排第一 ✅
2.  听
3.  挺
```

---

### 方法2：查看调试日志

启用调试日志：
```bash
export RIME_LOG_DIR=/tmp/rime_logs
./rime_console
```

查看日志：
```bash
cat /tmp/rime_logs/rime.console.INFO

# 搜索关键词
grep "contextual suggestion" /tmp/rime_logs/rime.console.INFO
```

如果启用了上下文评分，你会看到：
```
contextual suggestion: 庭 weight: -7.2
contextual suggestion: 听 weight: -15.5
contextual suggestion: 挺 weight: -17.8
```

---

## 📊 配置文件优先级

RIME 的配置加载顺序：

```
1. 主配置文件
   wanxiang.schema.yaml
   translator/contextual_suggestions: true
        ↓
2. 用户自定义配置
   custom/wanxiang.custom.yaml
   (如果存在，会覆盖主配置)
        ↓
3. 用户同步配置
   user_profile/sync/.../wanxiang.schema.yaml
   translator/contextual_suggestions: false  ← 最终生效
        ↓
4. 最终配置
   user_profile/build/wanxiang.schema.yaml
   (部署后的合并结果)
```

**关键点**：
- ❌ 用户同步配置的优先级最高
- ❌ 它会覆盖主配置文件
- ❌ 所以即使主配置是 `true`，最终也会被覆盖为 `false`

---

## 🎯 总结

### 问题根源

1. ❌ `contextual_suggestions: false` 在用户配置中
2. ❌ 没有调用 `ContextualWeighted`
3. ❌ 没有使用 Octagram 评分
4. ❌ 候选只按词典权重排序

### 解决方法

1. ✅ 修改用户配置文件，设置 `contextual_suggestions: true`
2. ✅ 或使用 custom.yaml 强制覆盖
3. ✅ 或删除用户配置，重新部署

### 预期效果

启用后，"庭" 会排到第一位，因为：
- 词典权重: -5.2
- 上下文评分: -2.0（"家庭"是强搭配）
- 最终权重: -7.2（最优）

### 关键配置

```yaml
# wanxiang.schema.yaml 或 wanxiang.custom.yaml
translator:
  contextual_suggestions: true  # 必须启用

grammar:
  language: zh-hans  # 使用简体中文语法模型
```

---

## 💡 额外建议

### 1. 检查语法数据库是否存在

确保有语法模型文件：
```bash
ls -la /Users/jimmy54/Pictures/jimmy_librime/librime/cmake-build-debug/bin/*.gram

# 应该看到：
# zh-hans.gram  或  zh-hant.gram
```

如果没有，需要下载或生成语法模型。

---

### 2. 调整 Octagram 参数（可选）

如果效果不理想，可以调整惩罚值：
```yaml
grammar:
  language: zh-hans
  collocation_min_length: 2
  non_collocation_penalty: -12    # 无搭配惩罚（默认）
  weak_collocation_penalty: -24   # 弱搭配惩罚（默认）
  collocation_penalty: -12        # 强搭配惩罚（默认）
```

**调整建议**：
- 增大 `non_collocation_penalty`（如 -15）→ 更强调搭配
- 减小 `collocation_penalty`（如 -8）→ 更奖励强搭配

---

### 3. 验证上下文是否正确传递

添加调试代码：
```cpp
// script_translator.cc L306-317
string ScriptTranslator::GetPrecedingText(size_t start) const {
  if (!contextual_suggestions_)
    return string();
  auto preceding_text = start > 0 
      ? engine_->context()->composition().GetTextBefore(start)
      : engine_->context()->commit_history().latest_text();
  
  // 添加调试输出
  LOG(INFO) << "Preceding text: [" << preceding_text << "]";
  
  return preceding_text;
}
```

重新编译后，查看日志确认上下文是否正确。
