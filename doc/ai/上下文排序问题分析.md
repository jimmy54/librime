# 上下文排序功能问题分析报告

## 📋 问题描述

你在使用 `set_context_text` API 设置上下文后，发现排序效果不明显：

### 测试案例1：单字上下文
- **左侧上下文**：吃
- **输入拼音**：fan
- **期望结果**：饭排在第1位
- **实际结果**：饭未排在第1位

### 测试案例2：多字上下文  
- **左侧上下文**：一心一
- **输入拼音**：yi
- **期望结果**：意排在第1位（一心一意）
- **实际结果**：意未排在第1位

---

## 🔍 根本原因分析

经过深入分析代码和实现逻辑，我发现了**7个可能导致上下文排序无效的原因**：

### 原因1：Grammar模块未加载 ⚠️ **最可能**

**问题**：`ContextualRankingFilter` 依赖 Octagram 插件提供的 `Grammar` 组件。

**代码位置**：`contextual_ranking_filter.cc:20-27`
```cpp
static Grammar* create_grammar(Config* config) {
  if (!config)
    return nullptr;
  if (auto* component = Grammar::Require("grammar")) {
    return component->Create(config);
  }
  return nullptr;  // ← 如果返回nullptr，过滤器不工作
}
```

**检查方法**：
```bash
# 查看编译的插件
ls build/lib/rime-plugins/

# 应该看到：
# librime-octagram.so (Linux)
# librime-octagram.dylib (macOS)
```

**解决方法**：
```bash
# 重新编译，确保包含octagram插件
cmake -B build -DBUILD_PLUGINS=ON
make -C build
```

---

### 原因2：方案配置缺失 ⚠️ **很可能**

**问题**：输入方案的YAML配置中未启用 `contextual_ranking_filter`。

**必需配置**：
```yaml
# ~/.config/rime/luna_pinyin.schema.yaml

engine:
  filters:
    - contextual_ranking_filter  # ← 必须添加这一行
    - simplifier
    - uniquifier

# 可选但推荐的配置
contextual_ranking_filter:
  contextual_ranking: true
  max_rerank_candidates: 20

grammar:
  language: zh-hant
  contextual_suggestions: true
```

**检查方法**：
```bash
cat ~/.config/rime/luna_pinyin.schema.yaml | grep -A 5 "filters:"
```

---

### 原因3：语法数据库文件缺失 ⚠️ **很可能**

**问题**：Octagram需要预训练的 `.gram` 文件来计算上下文分数。

**数据库位置**：
- `{shared_data_dir}/{language}.gram`
- 例如：`/usr/local/share/rime-data/zh-hant.gram`

**检查方法**：
```bash
# 查找.gram文件
find /usr/local/share/rime-data -name "*.gram"
find ~/.config/rime -name "*.gram"
ls -lh /usr/local/share/rime-data/*.gram
```

**如果没有文件**：
- 需要训练语法数据库
- 或从 [librime-octagram](https://github.com/lotem/librime-octagram) 下载预训练模型

---

### 原因4：上下文长度限制 ⚠️ **可能**

**问题**：Octagram默认只使用最后3-4个字符作为上下文。

**代码逻辑**：`octagram.cc:115-119`
```cpp
int n = (std::min)(grammar::kMaxEncodedUnicode,
                   config_->collocation_max_length - 1);
// 只取最后n个Unicode字符
string context_query = grammar::encode(
    last_n_unicode(context, n, context_len),
    str_end(context));
```

**影响分析**：
- **"吃" + "饭"**：只用1个字，上下文信息较少
- **"一心一" + "意"**：只用最后3个字"心一意"，丢失了第一个"一"

**配置调整**：
```yaml
grammar:
  collocation_max_length: 5  # 增加到5
  collocation_min_length: 2
```

---

### 原因5：候选词质量分数过高 ⚠️ **很可能**

**问题**：原始候选词的质量分数可能远高于上下文分数，导致重排序效果不明显。

**评分公式**：`contextual_ranking_filter.cc:99`
```cpp
double total_score = cand->quality() + left_score + right_score;
```

**举例说明**：
```
候选词"反"：
  - 原始质量：100
  - 上下文分："吃"+"反" = 5
  - 总分：105

候选词"饭"：
  - 原始质量：80
  - 上下文分："吃"+"饭" = 20
  - 总分：100

结果："反"(105) > "饭"(100)，"反"仍然排在前面
```

**解决方法**：增加上下文权重
```cpp
// 修改 contextual_ranking_filter.cc:99
double total_score = cand->quality() + 
                     left_score * 3.0 +   // 左侧权重 x3
                     right_score * 3.0;   // 右侧权重 x3
```

---

### 原因6：过滤器顺序问题 ⚠️ **可能**

**问题**：如果 `contextual_ranking_filter` 在其他过滤器之后，可能被覆盖。

**正确顺序**：
```yaml
engine:
  filters:
    - contextual_ranking_filter  # 应该在前面
    - simplifier
    - uniquifier
```

---

### 原因7：日志未启用，无法诊断 ⚠️

**问题**：没有日志输出，无法确定过滤器是否运行。

**启用日志**：
```c
traits.min_log_level = 0;  // INFO级别
traits.log_dir = "/tmp/rime_logs";
```

**查看日志**：
```bash
tail -f /tmp/rime_logs/rime.INFO
```

**预期日志内容**：
```
I1015 17:30:00 context.cc:335] Context::set_external_context: preceding="吃", following=""
I1015 17:30:00 contextual_ranking_filter.cc:70] ContextualRankingFilter: left="吃", right=""
I1015 17:30:00 contextual_ranking_filter.cc:101] Candidate: "饭" quality=80 left=20 right=0 total=100
I1015 17:30:00 contextual_ranking_filter.cc:101] Candidate: "反" quality=100 left=5 right=0 total=105
```

---

## 🛠️ 诊断步骤

### 步骤1：编译并运行诊断工具

我已经为你创建了专门的诊断工具：

```bash
# 编译诊断工具
g++ -o diagnose diagnose_context_ranking.cc \
    -I/usr/local/include \
    -L/usr/local/lib \
    -lrime

# 运行诊断
./diagnose

# 查看详细日志
tail -100 /tmp/rime_logs/rime.INFO
```

### 步骤2：检查模块加载

查看日志中是否有：
```
registering components from module 'grammar'
```

如果没有，说明 Grammar 模块未加载。

### 步骤3：检查方案配置

```bash
cat ~/.config/rime/luna_pinyin.schema.yaml | grep -A 10 "filters:"
cat ~/.config/rime/luna_pinyin.schema.yaml | grep -A 5 "grammar:"
```

### 步骤4：检查语法数据库

```bash
ls -lh /usr/local/share/rime-data/*.gram
ls -lh ~/.config/rime/*.gram
```

---

## 💡 解决方案

### 方案A：确保模块正确加载（最重要）

```bash
# 1. 重新编译，包含octagram插件
cd /Users/jimmy54/Pictures/jimmy_librime/librime
cmake -B build -DBUILD_PLUGINS=ON
make -C build

# 2. 安装
sudo make -C build install

# 3. 验证插件
ls build/lib/rime-plugins/
```

### 方案B：配置输入方案

编辑 `~/.config/rime/luna_pinyin.schema.yaml`：

```yaml
engine:
  filters:
    - contextual_ranking_filter
    - simplifier
    - uniquifier

contextual_ranking_filter:
  contextual_ranking: true
  max_rerank_candidates: 20

grammar:
  language: zh-hant
  contextual_suggestions: true
  collocation_max_length: 5
```

### 方案C：增加上下文权重

修改 `src/rime/gear/contextual_ranking_filter.cc:99`：

```cpp
// 原代码
double total_score = cand->quality() + left_score + right_score;

// 修改为（增加权重）
double total_score = cand->quality() * 0.5 +  // 降低原始质量权重
                     left_score * 3.0 +       // 增加左侧上下文权重
                     right_score * 3.0;       // 增加右侧上下文权重
```

### 方案D：准备语法数据库

如果缺少 `.gram` 文件：

```bash
# 下载预训练模型（如果有）
# 或使用librime-octagram的训练工具训练

# 临时方案：使用简化的语法模型
# 需要查看librime-octagram文档
```

---

## 📊 预期效果分析

### 测试1："吃" + "fan"

**理想情况**（有语法数据库）：
```
1. 饭 (quality=80, left=25, total=105)
2. 反 (quality=100, left=2, total=102)
3. 返 (quality=90, left=1, total=91)
```

**实际可能**（无语法数据库或权重不足）：
```
1. 反 (quality=100, left=0, total=100)
2. 饭 (quality=80, left=0, total=80)
3. 返 (quality=90, left=0, total=90)
```

### 测试2："一心一" + "yi"

**理想情况**：
```
1. 意 (quality=70, left=30, total=100) ← 成语加分
2. 一 (quality=150, left=5, total=155) ← 但"一"太常用
3. 以 (quality=80, left=2, total=82)
```

**挑战**：
- "一"的使用频率极高，原始质量分很高
- 需要更高的上下文权重才能让"意"排到第1位
- 或者需要专门的成语识别机制

---

## 🎯 下一步行动

1. **立即执行**：运行诊断工具
   ```bash
   ./diagnose
   ```

2. **查看日志**：确定问题所在
   ```bash
   tail -100 /tmp/rime_logs/rime.INFO
   ```

3. **根据诊断结果**：
   - 如果Grammar模块未加载 → 重新编译
   - 如果配置缺失 → 修改YAML
   - 如果.gram文件缺失 → 准备数据库
   - 如果权重不足 → 调整评分公式

4. **反馈信息**：
   - 诊断工具的输出结果
   - 日志文件内容
   - 是否存在.gram文件

---

## 📝 总结

上下文排序功能的实现是正确的，但**能否生效取决于多个条件**：

✅ **已实现**：
- API接口 `set_context_text`
- Context类的外部上下文存储
- ContextualRankingFilter过滤器
- Translator的上下文优先级

⚠️ **需要满足的条件**：
1. Grammar模块（Octagram插件）已加载
2. 方案配置包含 `contextual_ranking_filter`
3. 存在语法数据库 `.gram` 文件
4. 上下文权重足够高

请运行诊断工具，然后告诉我结果，我会帮你进一步分析和解决问题。
